{"/home/travis/build/npmtest/node-npmtest-swagger/test.js":"/* istanbul instrument in package npmtest_swagger */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-swagger/lib.npmtest_swagger.js":"/* istanbul instrument in package npmtest_swagger */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_swagger = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_swagger = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-swagger/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-swagger && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_swagger */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_swagger\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_swagger.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_swagger.rollup.js'] =\n            local.assetsDict['/assets.npmtest_swagger.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_swagger.__dirname + '/lib.npmtest_swagger.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-swagger/node_modules/swagger/index.js":"","/home/travis/build/npmtest/node-npmtest-swagger/node_modules/swagger/bin/swagger.js":"#!/usr/bin/env node\n/****************************************************************************\n Copyright 2015 Apigee Corporation\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n ****************************************************************************/\n'use strict';\n\nvar app = require('commander');\nvar browser = require('../lib/util/browser');\nvar rootCommands = require('../lib/commands/commands');\nvar cli = require('../lib/util/cli');\nvar execute = cli.execute;\n\napp.version(require('../lib/util/cli').version());\n\napp\n  .command('project <action>', 'project actions');\n\napp\n  .command('docs')\n  .description('open Swagger documentation')\n  .action(function() {\n    browser.open('https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md', function() {\n      process.exit(0);\n    });\n  });\n\napp\n  .command('validate [swaggerFile]')\n  .description('validate a Swagger document (supports unix piping)')\n  .option('-j, --json', 'output as JSON')\n  .action(execute(rootCommands.validate));\n\napp\n  .command('convert <swaggerFile> [apiDeclarations...]')\n  .description('Converts Swagger 1.2 documents to a Swagger 2.0 document')\n  .option('-o, --output-file <fileName>', 'specify an output-file to write to')\n  .action(execute(rootCommands.convert));\n\napp.parse(process.argv);\ncli.validate(app);","/home/travis/build/npmtest/node-npmtest-swagger/node_modules/swagger/lib/util/browser.js":"/****************************************************************************\n Copyright 2015 Apigee Corporation\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n ****************************************************************************/\n'use strict';\n\nvar Child = require('child_process');\nvar config = require('../../config');\nvar emit = require('./feedback').emit;\n\nvar platformOpeners = {\n\n  darwin:\n    function(url, cb) {\n      var browser = escape(config.browser);\n      if (browser) {\n        open('open -a ' + browser, url, cb);\n      } else {\n        open('open', url, cb);\n      }\n    },\n\n  win32:\n    function(url, cb) {\n      var browser = escape(config.browser);\n      if (browser) {\n        open('start \"\" \"' + browser + '\"', url, cb);\n      } else {\n        open('start \"\"', url, cb);\n      }\n    },\n\n  linux:\n    function(url, cb) {\n      var browser = escape(config.browser);\n      if (browser) {\n        open(browser, url, cb);\n      } else {\n        open('xdg-open', url, cb);\n      }\n    },\n\n  other:\n    function(url, cb) {\n      var browser = escape(config.browser);\n      if (browser) {\n        open(browser, url, cb);\n      } else {\n        cb(new Error('must specify browser in config'));\n      }\n    }\n};\n\nmodule.exports = {\n  open: platformOpen\n};\n\n// note: platform parameter is just for testing...\nfunction platformOpen(url, cb, platform) {\n  platform = platform || process.platform;\n  if (!platformOpeners[platform]) { platform = 'other'; }\n  platformOpeners[platform](url, cb);\n}\n\nfunction open(command, url, cb) {\n  if (config.debug) { emit('command: ' + command); }\n  emit('Opening browser to: ' + url);\n  Child.exec(command + ' \"' + escape(url) + '\"', cb);\n}\n\nfunction escape(s) {\n  if (!s) { return s; }\n  return s.replace(/\"/g, '\\\\\\\"');\n}\n","/home/travis/build/npmtest/node-npmtest-swagger/node_modules/swagger/config/index.js":"/****************************************************************************\n Copyright 2015 Apigee Corporation\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n ****************************************************************************/\n'use strict';\n\nvar path = require('path');\nvar _ = require('lodash');\nvar debug = require('debug')('swagger');\n\nvar config = {\n  rootDir: path.resolve(__dirname, '..'),\n  userHome: process.env[(process.platform == 'win32') ? 'USERPROFILE' : 'HOME'],\n  debug: !!process.env.DEBUG\n};\nconfig.nodeModules = path.resolve(config.rootDir, 'node_modules');\n\nmodule.exports = config;\n\n// swagger editor //\n\nconfig.swagger = {\n  fileName: 'api/swagger/swagger.yaml',\n  editorDir: path.resolve(config.nodeModules, 'swagger-editor'),\n  editorConfig: {\n    analytics: { google: { id: null } },\n    disableCodeGen: true,\n    disableNewUserIntro: true,\n    examplesFolder: '/spec-files/',\n    exampleFiles: [],\n    autocompleteExtension: {},\n    useBackendForStorage: true,\n    backendEndpoint: '/editor/spec',\n    backendHealthCheckTimeout: 5000,\n    useYamlBackend: true,\n    disableFileMenu: true,\n    enableTryIt: true,\n    headerBranding: false,\n    brandingCssClass: null,\n    schemaUrl: '/schema/swagger.json',\n    importProxyUrl: 'https://cors-it.herokuapp.com/?url='\n  }\n};\n\n// project //\n\nconfig.project = {\n  port: process.env.PORT || 10010,\n  skeletonsDir: path.resolve(__dirname, '..', 'project-skeletons')\n};\n\n// load env vars //\n\n_.each(process.env, function(value, key) {\n  var split = key.split('_');\n  if (split[0] === 'swagger') {\n    var configItem = config;\n    for (var i = 1; i < split.length; i++) {\n      var subKey = split[i];\n      if (i < split.length - 1) {\n        if (!configItem[subKey]) { configItem[subKey] = {}; }\n        configItem = configItem[subKey];\n      } else {\n        configItem[subKey] = value;\n      }\n    }\n    debug('loaded env var: %s = %s', split.slice(1).join('.'), value);\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-swagger/node_modules/swagger/lib/util/feedback.js":"/****************************************************************************\n Copyright 2015 Apigee Corporation\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n ****************************************************************************/\n'use strict';\n\nvar EventEmitter = require('events').EventEmitter;\nvar feedback = new EventEmitter();\nvar CHANNEL = 'feedback';\nvar util = require('util');\nvar _ = require('lodash');\n\nmodule.exports = {\n\n  on: function(cb) {\n    feedback.on(CHANNEL, function(feedback) {\n      cb(feedback);\n    });\n  },\n\n  emit: function(string) {\n    if (Buffer.isBuffer(string)) { string = string.toString(); }\n    if (arguments.length > 1 && _.isString(string)) {\n      string = util.format.apply(this, arguments);\n    }\n    feedback.emit(CHANNEL, string);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-swagger/node_modules/swagger/lib/commands/commands.js":"#!/usr/bin/env node\n/****************************************************************************\n Copyright 2015 Apigee Corporation\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n ****************************************************************************/\n'use strict';\n\nvar swaggerConverter = require('swagger-converter');\nvar swaggerSpec = require('../util/spec');\nvar yaml = require('js-yaml');\nvar join = require('path').join;\nvar fs = require('fs');\n\nvar convert = function convert(filePath, apiDeclarations, options, cb) {\n  if (filePath) {\n    if (!fs.existsSync(join(process.cwd(), filePath))) {\n      return cb(error);\n    }\n\n    var resource = fs.readFileSync(join(process.cwd(), filePath), 'utf8');\n    var json;\n\n    try {\n      json = JSON.parse(resource);\n    } catch (error) {\n      return cb(error);\n    }\n\n    var declarations = [];\n    var tempJson;\n\n    apiDeclarations.forEach(function(currentValue) {\n      if (!fs.existsSync(join(process.cwd(), currentValue))) {\n        return cb(error);\n      }\n\n      try {\n        tempJson = JSON.parse(fs.readFileSync(join(process.cwd(), currentValue), 'utf8'))\n      } catch (error) {\n        return cb(error);\n      }\n\n      declarations.push(tempJson);\n    });\n\n    var swagger2 = yaml.safeDump(swaggerConverter(json, declarations));\n\n    if (options.outputFile) {\n      fs.writeFile(join(process.cwd(), options.outputFile), swagger2, function(err) {\n        if (err) {return cb(err);}\n      });\n    } else {\n      cb(null, swagger2);\n    }\n  }\n}\n\nvar validate = function validate(file, options, cb) {\n\n  if (!file) { // check stream\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    process.stdin.on('data', function(data) {\n      if (!data) { process.exit(1); }\n      swaggerSpec.validateSwagger(parse(data), options, cb);\n    });\n  } else {\n    var data = fs.readFileSync(file, 'utf8');\n    swaggerSpec.validateSwagger(parse(data), options, cb);\n  }\n}\n\nfunction parse(data) {\n  if (isJSON(data)) {\n    return JSON.parse(data);\n  } else {\n    return yaml.safeLoad(data);\n  }\n}\n\nfunction isJSON(data) {\n  return data.match(/^\\s*\\{/);\n}\n\nmodule.exports = {\n  convert: convert,\n  validate: validate\n}\n","/home/travis/build/npmtest/node-npmtest-swagger/node_modules/swagger-converter/index.js":"/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014 Apigee Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n'use strict';\n\nvar assert = require('assert');\nvar URI = require('URIjs');\n\nif (typeof window === 'undefined') {\n  module.exports = convert;\n} else {\n  window.SwaggerConverter = window.SwaggerConverter || {\n    convert: convert\n  };\n}\n\n/**\n * Swagger Converter Error\n * @param {string} message - error message\n */\nfunction SwaggerConverterError(message) {\n  this.message = message;\n  this.stack = Error().stack;\n}\nSwaggerConverterError.prototype = Object.create(Error.prototype);\nSwaggerConverterError.prototype.name = 'SwaggerConverterError';\n\n/*\n * Converts Swagger 1.2 specs file to Swagger 2.0 specs.\n * @param resourceListing {object} - root Swagger 1.2 document where it has a\n *  list of all paths\n * @param apiDeclarations {array} - a list of all resources listed in\n * resourceListing. Array of objects\n * @returns {object} - Fully converted Swagger 2.0 document\n*/\nfunction convert(resourceListing, apiDeclarations) {\n  var converter = new Converter();\n  return converter.convert(resourceListing, apiDeclarations);\n}\n\nvar Converter = function() {};\nvar prototype = Converter.prototype;\n\n/*\n * Converts Swagger 1.2 specs file to Swagger 2.0 specs.\n * @param resourceListing {object} - root of Swagger 1.2 document\n * @param apiDeclarations {array} - a list of resources\n * @returns {object} - Fully converted Swagger 2.0 document\n*/\nprototype.convert = function(resourceListing, apiDeclarations) {\n  assert(typeof resourceListing === 'object');\n\n  var securityDefinitions =\n    this.buildSecurityDefinitions(resourceListing.authorizations);\n\n  var tags = [];\n  var paths = {};\n  var definitions = {};\n\n  if (this.isEmbeddedDocument(resourceListing)) {\n    apiDeclarations = [resourceListing];\n  }\n  else {\n    tags = this.buildTags(resourceListing, apiDeclarations);\n  }\n\n  this.customTypes = [];\n  this.forEach(apiDeclarations, function(resource) {\n    if (isValue(resource.models)) {\n      //TODO: check that types don't overridden\n      this.customTypes = this.customTypes.concat(Object.keys(resource.models));\n    }\n  });\n\n  this.forEach(apiDeclarations, function(declaration, index) {\n    var operationTags;\n\n    var tag = tags[index];\n    if (isValue(tag)) {\n      operationTags = [tag.name];\n    }\n\n    extend(definitions, this.buildDefinitions(declaration.models));\n    extend(paths, this.buildPaths(declaration, operationTags));\n  });\n\n  return extend({},\n    this.aggregatePathComponents(resourceListing, apiDeclarations),\n    {\n      swagger: '2.0',\n      info: this.buildInfo(resourceListing),\n      tags: undefinedIfEmpty(removeNonValues(tags)),\n      paths: undefinedIfEmpty(paths),\n      securityDefinitions: undefinedIfEmpty(securityDefinitions),\n      definitions: undefinedIfEmpty(definitions)\n    }\n  );\n};\n\n/*\n * Builds \"tags\" section of Swagger 2.0 document\n * @param resourceListing {object} - root of Swagger 1.2 document\n * @param apiDeclarations {array} - a list of resources\n * @returns {array} - list of Swagger 2.0 tags\n*/\nConverter.prototype.buildTags = function(resourceListing, apiDeclarations) {\n  assert(!isEmpty(apiDeclarations));\n\n  var paths = [];\n  this.forEach(apiDeclarations, function(declaration) {\n    var path = declaration.resourcePath;\n    if (isValue(path) && paths.indexOf(path) === -1) {\n      paths.push(path);\n    }\n  });\n\n  //'resourcePath' is optional parameter and also frequently have invalid values\n  //if so than we don't create any tags at all.\n  //TODO: generate replacement based on longest common prefix for paths in resource.\n  if (paths.length < apiDeclarations.length) {\n    return [];\n  }\n\n  //TODO: better way to mach tag names and descriptions\n  var tagDescriptions = {};\n  this.forEach(resourceListing.apis, function(resource) {\n    var tagName = this.extractTag(resource.path);\n    if (!isValue(tagName)) { return; }\n\n    tagDescriptions[tagName] = resource.description;\n  });\n\n  var tags = [];\n  this.forEach(paths, function(path) {\n    var name = this.extractTag(path);\n    var description = tagDescriptions[name];\n\n    tags.push(extend({}, {\n      name: name,\n      description: description\n    }));\n  });\n\n  return tags;\n};\n\n/*\n * Extract name of the tag from resourcePath\n * @param resourcePath {string} - Swagger 1.2 resource path\n * @returns {string} - tag name\n*/\nprototype.extractTag = function(resourcePath) {\n  var tag = URI(resourcePath || '').path(true)\n    .replace('{format}', 'json')\n    .replace(/\\/$/, '')\n    .replace(/.json$/, '')\n    .split(['/']).pop();\n\n  return tag || undefined;\n};\n\n/*\n * Test if object is embedded document\n * @param resourceListing {object} - root of Swagger 1.2 document\n * @returns {boolean} - result of test\n*/\nprototype.isEmbeddedDocument = function(resourceListing) {\n  var seenOperations = false;\n  var seenApiDeclaration = false;\n\n  this.forEach(resourceListing.apis, function(resource) {\n    if (!isEmpty(resource.operations)) {\n      seenOperations = true;\n    }\n    else if (isValue(resource.path)) {\n      seenApiDeclaration = true;\n    }\n\n    if (seenOperations && seenApiDeclaration) {\n      throw new SwaggerConverterError(\n        'Resource listing can not have both operations and API declarations.');\n    }\n  });\n\n  return seenOperations;\n};\n\n/*\n * Builds \"info\" section of Swagger 2.0 document\n * @param resourceListing {object} - root of Swagger 1.2 document\n * @returns {object} - \"info\" section of Swagger 2.0 document\n*/\nprototype.buildInfo = function(resourceListing) {\n  var info = {\n    title: 'Title was not specified',\n    version: resourceListing.apiVersion || '1.0.0',\n  };\n\n  var oldInfo = resourceListing.info;\n  if (!isValue(oldInfo)) {\n    return info;\n  }\n\n  var contact = extend({}, {email: oldInfo.contact});\n  var license;\n\n  if (isValue(oldInfo.license)) {\n    license = extend({}, {\n      name: oldInfo.license,\n      url: oldInfo.licenseUrl\n    });\n  }\n\n  return extend(info, {\n    title: oldInfo.title,\n    description: oldInfo.description,\n    contact: undefinedIfEmpty(contact),\n    license: undefinedIfEmpty(license),\n    termsOfService: oldInfo.termsOfServiceUrl\n  });\n};\n\n/*\n * Merge path components from all resources.\n * @param resourceListing {object} - root of Swagger 1.2 document\n * @param apiDeclarations {array} - a list of resources\n * @returns {object} - Swagger 2.0 path components\n * @throws {SwaggerConverterError}\n*/\nprototype.aggregatePathComponents = function(resourceListing, apiDeclarations) {\n  var path = extend({}, this.buildPathComponents(resourceListing.basePath));\n\n  var globalBasePath;\n  this.forEach(apiDeclarations, function(api) {\n    var basePath = api.basePath;\n    //Test if basePath is relative(start with '.' or '..').\n    if (/^\\.\\.?(\\/|$)/.test(basePath)) {\n      basePath = URI(basePath).absoluteTo(path.basePath).path(true);\n    }\n\n    //TODO: Swagger 1.2 support per resource 'basePath', but Swagger 2.0 doesn't\n    // solution could be to create separate spec per each 'basePath'.\n    if (isValue(globalBasePath) && basePath !== globalBasePath) {\n      throw new SwaggerConverterError(\n        'Resources can not override each other basePaths');\n    }\n    globalBasePath = basePath;\n  });\n\n  return extend(path, this.buildPathComponents(globalBasePath));\n};\n\n/*\n * Get host, basePath and schemes for Swagger 2.0 result document from\n * Swagger 1.2 basePath.\n * @param basePath {string} - the base path from Swagger 1.2\n * @returns {object} - Swagger 2.0 path components\n*/\nprototype.buildPathComponents = function(basePath) {\n  if (!basePath) { return {}; }\n\n  var url = URI(basePath).absoluteTo('/');\n  var protocol = url.protocol();\n  return extend({}, {\n    host: url.host(),\n    basePath: url.path(true),\n    schemes: protocol && [protocol]\n  });\n};\n\n/*\n * Builds a Swagger 2.0 type properties from a Swagger 1.2 type properties\n *\n * @param oldDataType {object} - Swagger 1.2 type object\n *\n * @returns {object} - Swagger 2.0 equivalent\n * @throws {SwaggerConverterError}\n */\nprototype.buildTypeProperties = function(oldType, allowRef) {\n  if (!oldType) { return {}; }\n  assert(typeof allowRef === 'boolean');\n\n  oldType = oldType.trim();\n\n  if (allowRef && this.customTypes.indexOf(oldType) !== -1) {\n    return {$ref: '#/definitions/' + oldType};\n  }\n\n  var typeMap = {\n    //Swagger 1.2 types\n    integer:     {type: 'integer'},\n    number:      {type: 'number'},\n    string:      {type: 'string'},\n    boolean:     {type: 'boolean'},\n    array:       {type: 'array'},\n    object:      {type: 'object'},\n    file:        {type: 'file'},\n    void:        {},\n    //Swagger 1.1 types\n    int:         {type: 'integer', format: 'int32'},\n    long:        {type: 'integer', format: 'int64'},\n    float:       {type: 'number',  format: 'float'},\n    double:      {type: 'number',  format: 'double'},\n    byte:        {type: 'string',  format: 'byte'},\n    date:        {type: 'string',  format: 'date'},\n    list:        {type: 'array'},\n    set:         {type: 'array', uniqueItems: true},\n    //JSON Schema Draft-3\n    any:         {},\n    //Unofficial but very common mistakes\n    datetime:    {type: 'string',  format: 'date-time'},\n    'date-time': {type: 'string',  format: 'date-time'},\n    map:         {type: 'object'}\n  };\n\n  var type = typeMap[oldType.toLowerCase()];\n  if (isValue(type)) {\n    return type;\n  }\n\n  //handle \"<TYPE>[<ITEMS>]\" types from 1.1 spec\n  //use RegEx with capture groups to get <TYPE> and <ITEMS> values.\n  var match = oldType.match(/^([^[]*)\\[(.*)\\]$/);\n  if (isValue(match)) {\n    var collection = match[1].toLowerCase();\n    var items = match[2];\n\n    //handle \"Map[String,<VALUES>]\" types\n    //see https://github.com/swagger-api/swagger-core/issues/244\n    if (collection === 'map') {\n      var commaIndex = items.indexOf(',');\n      var keyType = items.slice(0, commaIndex);\n      var valueType = items.slice(commaIndex + 1);\n      if (keyType.toLowerCase() === 'string') {\n        return {\n          additionalProperties: this.buildTypeProperties(valueType, allowRef)\n        };\n      }\n    }\n    else {\n      type = typeMap[collection];\n      if (isValue(type)) {\n        type.items = this.buildTypeProperties(items, allowRef);\n        return type;\n      }\n    }\n  }\n\n  //At this point we know that it not standard type, but at the same time we\n  //can't find such user type. To proceed further we just add it as is.\n  //TODO: add warning\n  return allowRef ? {$ref: '#/definitions/' + oldType} : {type: oldType};\n};\n\n/*\n * Builds a Swagger 2.0 data type properties from a Swagger 1.2 data type properties\n *\n * @see {@link https://github.com/swagger-api/swagger-spec/blob/master/versions/\n *  1.2.md#433-data-type-fields}\n *\n * @param oldDataType {object} - Swagger 1.2 data type object\n *\n * @returns {object} - Swagger 2.0 equivalent\n */\nprototype.buildDataType = function(oldDataType, allowRef) {\n  if (!oldDataType) { return {}; }\n  assert(typeof oldDataType === 'object');\n  assert(typeof allowRef === 'boolean');\n\n  var oldTypeName = oldDataType.type || oldDataType.dataType ||\n    oldDataType.responseClass || oldDataType.$ref;\n\n  var result = this.buildTypeProperties(oldTypeName, allowRef);\n\n  var oldItems = oldDataType.items;\n  if (isValue(oldItems)) {\n    if (typeof oldItems === 'string') {\n      oldItems = {type: oldItems};\n    }\n    oldItems = this.buildDataType(oldItems, allowRef);\n  }\n\n  //TODO: handle '0' in default\n  var defaultValue = oldDataType.default || oldDataType.defaultValue;\n  if (result.type !== 'string') {\n    defaultValue = fixNonStringValue(defaultValue, true);\n  }\n\n  //TODO: support 'allowableValues' from 1.1 spec\n\n  extend(result, {\n    format: oldDataType.format,\n    items: oldItems,\n    uniqueItems: fixNonStringValue(oldDataType.uniqueItems),\n    minimum: fixNonStringValue(oldDataType.minimum),\n    maximum: fixNonStringValue(oldDataType.maximum),\n    default: defaultValue,\n    enum: oldDataType.enum,\n  });\n\n  if (result.type === 'array' && !isValue(result.items)) {\n    result.items = {};\n  }\n\n  return result;\n};\n\n/*\n * Builds a Swagger 2.0 paths object form a Swagger 1.2 path object\n * @param apiDeclaration {object} - Swagger 1.2 apiDeclaration\n * @param tag {array} - array of Swagger 2.0 tag names\n * @returns {object} - Swagger 2.0 path object\n*/\nprototype.buildPaths = function(apiDeclaration, tags) {\n  var paths = {};\n\n  var operationDefaults = {\n    produces: apiDeclaration.produces,\n    consumes: apiDeclaration.consumes,\n    tags: tags,\n    security: undefinedIfEmpty(\n      this.buildSecurity(apiDeclaration.authorizations))\n  };\n\n  this.forEach(apiDeclaration.apis, function(api) {\n    if (!isValue(api.operations)) { return; }\n\n    var pathString = URI(api.path).absoluteTo('/').path(true);\n    pathString = pathString.replace('{format}', 'json');\n\n    if (!isValue(paths[pathString])) {\n      paths[pathString] = {};\n    }\n    var path = paths[pathString];\n\n    this.forEach(api.operations, function(oldOperation) {\n      var method = oldOperation.method || oldOperation.httpMethod;\n      method = method.toLowerCase();\n      path[method] = this.buildOperation(oldOperation, operationDefaults);\n    });\n  });\n\n  return paths;\n};\n\n/*\n * Builds a Swagger 2.0 security object form a Swagger 1.2 authorizations object\n * @param oldAuthorizations {object} - Swagger 1.2 authorizations object\n * @returns {object} - Swagger 2.0 security object\n*/\nprototype.buildSecurity = function(oldAuthorizations) {\n  var security = [];\n  this.mapEach(oldAuthorizations, function(oldScopes, oldName) {\n    var names = this.securityNamesMap[oldName];\n    if (isEmpty(names)) {\n      //TODO: add warning\n      names = [oldName];\n    }\n\n    this.forEach(names, function(name) {\n      var requirement = {};\n      requirement[name] = this.mapEach(oldScopes, function(oldScope) {\n        return oldScope.scope;\n      });\n      security.push(requirement);\n    });\n  });\n  return security;\n};\n\n/*\n * Builds a Swagger 2.0 operation object form a Swagger 1.2 operation object\n * @param oldOperation {object} - Swagger 1.2 operation object\n * @param operationDefaults {object} - defaults from containing apiDeclaration\n * @returns {object} - Swagger 2.0 operation object\n*/\nprototype.buildOperation = function(oldOperation, operationDefaults) {\n  var parameters = [];\n\n  this.forEach(oldOperation.parameters, function(oldParameter) {\n    parameters.push(this.buildParameter(oldParameter));\n  });\n\n  return extend({}, operationDefaults, {\n    operationId: oldOperation.nickname,\n    summary: oldOperation.summary,\n    description: oldOperation.description || oldOperation.notes,\n    deprecated: fixNonStringValue(oldOperation.deprecated),\n    produces: oldOperation.produces,\n    consumes: oldOperation.consumes,\n    parameters: undefinedIfEmpty(parameters),\n    responses: this.buildResponses(oldOperation),\n    security: undefinedIfEmpty(this.buildSecurity(oldOperation.authorizations))\n  });\n};\n\n/*\n * Builds a Swagger 2.0 responses object form a Swagger 1.2 responseMessages object\n * @param oldOperation {object} - Swagger 1.2 operation object\n * @returns {object} - Swagger 2.0 response object\n*/\nprototype.buildResponses = function(oldOperation) {\n  var responses = {\n    '200': {description: 'No response was specified'}\n  };\n\n  this.forEach(oldOperation.responseMessages, function(oldResponse) {\n    var code = '' + oldResponse.code;\n    responses[code] = extend({}, {\n      description: oldResponse.message || 'Description was not specified',\n      schema: undefinedIfEmpty(\n        this.buildTypeProperties(oldResponse.responseModel, true))\n    });\n  });\n\n  extend(responses['200'], {\n    schema: undefinedIfEmpty(this.buildDataType(oldOperation, true))\n  });\n\n  return responses;\n};\n\n/*\n * Converts Swagger 1.2 parameter object to Swagger 2.0 parameter object\n * @param oldParameter {object} - Swagger 1.2 parameter object\n * @returns {object} - Swagger 2.0 parameter object\n * @throws {SwaggerConverterError}\n*/\nprototype.buildParameter = function(oldParameter) {\n  var parameter = extend({}, {\n    in: oldParameter.paramType,\n    description: oldParameter.description,\n    name: oldParameter.name,\n    required: fixNonStringValue(oldParameter.required)\n  });\n\n  if (parameter.in === 'form') {\n    parameter.in = 'formData';\n  }\n\n  if (oldParameter.paramType === 'body') {\n    parameter.schema = this.buildDataType(oldParameter, true);\n    if (!isValue(parameter.name)) {\n      parameter.name = 'body';\n    }\n    return parameter;\n  }\n\n  var schema = this.buildDataType(oldParameter, false);\n\n  //Encoding of non-body arguments is the same not matter which type is specified.\n  //So type only affects parameter validation, so it \"safe\" to add missing types.\n  if (!isValue(schema.type)) {\n    schema.type = 'string';\n  }\n\n  if (schema.type === 'array' && !isValue(schema.items.type)) {\n    schema.items.type = 'string';\n  }\n\n  var allowMultiple = fixNonStringValue(oldParameter.allowMultiple);\n  //Non-body parameters doesn't support array inside array. But in some specs\n  //both 'allowMultiple' is true and 'type' is array, so just ignore it.\n  if (allowMultiple === true && schema.type !== 'array') {\n    schema = {type: 'array', items: schema};\n  }\n\n  //According to Swagger 2.0 spec: If the parameter is in \"path\",\n  //this property is required and its value MUST be true.\n  if (parameter.in === 'path') {\n    schema.required = true;\n  }\n\n  return extend(parameter, schema);\n};\n\n/*\n * Converts Swagger 1.2 authorization definitions into Swagger 2.0 definitions\n * Definitions couldn't be converted 1 to 1, 'this.securityNamesMap' should be\n * used to map between Swagger 1.2 names and one or more Swagger 2.0 names.\n *\n * @param oldAuthorizations {object} - The Swagger 1.2 Authorizations definitions\n * @returns {object} - Swagger 2.0 security definitions\n */\nprototype.buildSecurityDefinitions = function(oldAuthorizations) {\n  var securityDefinitions = {};\n\n  this.securityNamesMap = {};\n  this.forEach(oldAuthorizations, function(oldAuthorization, name) {\n    var scopes = {};\n    this.forEach(oldAuthorization.scopes, function(oldScope) {\n      var name = oldScope.scope;\n      scopes[name] = oldScope.description || ('Undescribed ' + name);\n    });\n\n    var securityDefinition = extend({}, {\n      type: oldAuthorization.type,\n      in: oldAuthorization.passAs,\n      name: oldAuthorization.keyname,\n      scopes: undefinedIfEmpty(scopes)\n    });\n\n    if (securityDefinition.type === 'basicAuth') {\n      securityDefinition.type = 'basic';\n    }\n\n    if (!isValue(oldAuthorization.grantTypes)) {\n      securityDefinitions[name] = securityDefinition;\n      this.securityNamesMap[name] = [name];\n      return;\n    }\n\n    this.securityNamesMap[name] = [];\n    // For OAuth2 types, 1.2 describes multiple \"flows\" in one authorization\n    // object. But for 2.0 we need to create one security definition per flow.\n    this.forEach(oldAuthorization.grantTypes, function(oldGrantType, gtName) {\n      var grantParameters = {};\n\n      switch (gtName) {\n      case 'implicit':\n        extend(grantParameters, {\n          flow: 'implicit',\n          authorizationUrl: getValue(oldGrantType, 'loginEndpoint', 'url')\n        });\n        break;\n\n      case 'authorization_code':\n        extend(grantParameters, {\n          flow: 'accessCode',\n          tokenUrl: getValue(oldGrantType, 'tokenEndpoint', 'url'),\n          authorizationUrl:\n            getValue(oldGrantType, 'tokenRequestEndpoint', 'url')\n        });\n        break;\n      }\n\n      var oName = name;\n      if (getLength(oldAuthorization.grantTypes) > 1) {\n        oName += '_' + grantParameters.flow;\n      }\n\n      this.securityNamesMap[name].push(oName);\n      securityDefinitions[oName] =\n        extend({}, securityDefinition, grantParameters);\n    });\n  });\n\n  return securityDefinitions;\n};\n\n/*\n * Converts a Swagger 1.2 model object to a Swagger 2.0 model object\n * @param model {object} - Swagger 1.2 model object\n * @returns {object} - Swagger 2.0 model object\n*/\nprototype.buildModel = function(oldModel) {\n  var required = [];\n  var properties = {};\n\n  this.forEach(oldModel.properties, function(oldProperty, propertyName) {\n    if (fixNonStringValue(oldProperty.required) === true) {\n      required.push(propertyName);\n    }\n\n    properties[propertyName] = extend({},\n      this.buildDataType(oldProperty, true),\n      {description: oldProperty.description}\n    );\n  });\n\n  required = oldModel.required || required;\n\n  return extend(this.buildDataType(oldModel, true),\n  {\n    description: oldModel.description,\n    required: undefinedIfEmpty(required),\n    properties: undefinedIfEmpty(properties),\n    discriminator: oldModel.discriminator\n  });\n};\n\n/*\n * Converts the \"models\" object of Swagger 1.2 specs to Swagger 2.0 definitions\n * object\n * @param oldModels {object} - an object containing Swagger 1.2 objects\n * @returns {object} - Swagger 2.0 definitions object\n * @throws {SwaggerConverterError}\n*/\nprototype.buildDefinitions = function(oldModels) {\n  var models = {};\n\n  this.forEach(oldModels, function(oldModel, modelId) {\n    models[modelId] = this.buildModel(oldModel);\n  });\n\n  this.forEach(oldModels, function(parent, parentId) {\n    this.forEach(parent.subTypes, function(childId) {\n      var child = models[childId];\n\n      if (!isValue(child)) {\n        throw new SwaggerConverterError('subTypes resolution: Missing \"' +\n          childId + '\" type');\n      }\n\n      if (!isValue(child.allOf)) {\n        models[childId] = child = {allOf: [child]};\n      }\n\n      child.allOf.push({$ref: '#/definitions/' + parentId});\n    });\n  });\n\n  return models;\n};\n\n/*\n * Map elements of collection into array by invoking iteratee for each element\n * @param collection {array|object} - the collection to iterate over\n * @parma iteratee {function} - the function invoked per iteration\n * @returns {array|undefined} - result\n*/\nprototype.mapEach = function(collection, iteratee) {\n  var result = [];\n  this.forEach(collection, function(value, key) {\n    result.push(iteratee.bind(this)(value, key));\n  });\n  return result;\n};\n\n/*\n * Iterates over elements of collection invoking iteratee for each element\n * @param collection {array|object} - the collection to iterate over\n * @parma iteratee {function} - the function invoked per iteration\n*/\nprototype.forEach = function(collection, iteratee) {\n  if (!isValue(collection)) {\n    return;\n  }\n\n  if (typeof collection !== 'object') {\n    throw new SwaggerConverterError('Expected array or object, instead got: ' +\n      JSON.stringify(collection, null, 2));\n  }\n\n  iteratee = iteratee.bind(this);\n  if (Array.isArray(collection)) {\n    collection.forEach(iteratee);\n  }\n  else {\n    Object.keys(collection).forEach(function(key) {\n      iteratee(collection[key], key);\n    });\n  }\n};\n\n/*\n * Extends an object with another\n * @param destination {object} - object that will get extended\n * @parma source {object} - object the will used to extend source\n*/\nfunction extend(destination) {\n  assert(typeof destination === 'object');\n\n  function assign(source) {\n    if (!source) { return; }\n    Object.keys(source).forEach(function(key) {\n      var value = source[key];\n      if (isValue(value)) {\n        destination[key] = value;\n      }\n    });\n  }\n\n  for (var i = 1; i < arguments.length; ++i) {\n    assign(arguments[i]);\n  }\n  return destination;\n}\n\n/*\n * Test if value is empty and if so return undefined\n * @param value {*} - value to test\n * @returns {array|object|undefined} - result\n*/\nfunction undefinedIfEmpty(value) {\n  return isEmpty(value) ? undefined : value;\n}\n\n/*\n * Filter out all non value elements(null, undefined) from array\n * @param collection {array} - the collection to filter\n * @returns {array} - result\n*/\nfunction removeNonValues(collection) {\n  if (!isValue(collection)) {\n    return collection;\n  }\n\n  assert(Array.isArray(collection));\n\n  var result = [];\n  collection.forEach(function(value) {\n    if (isValue(value)) {\n      result.push(value);\n    }\n  });\n  return result;\n}\n\n/*\n * Test if value isn't null or undefined\n * @param value {*} - value to test\n * @returns {boolean} - result of test\n*/\nfunction isValue(value) {\n  //Some implementations use empty strings as undefined.\n  //For all fields we can drop empty string without any problems.\n  //One notable exception is 'default' values, but it better to\n  //skip it instead of providing unintended value.\n  if (value === '') {\n    return false;\n  }\n\n  return (value !== undefined && value !== null);\n}\n\n/*\n * Get length of container(Array or Object).\n * @param value {*} - container\n * @returns {number} - length of container\n*/\nfunction getLength(value) {\n  if (typeof value !== 'object') {\n    return 0;\n  }\n\n  if (isValue(value.length)) {\n    return value.length;\n  }\n\n  return Object.keys(value).length;\n}\n\n/*\n * Test if value is empty\n * @param value {*} - value to test\n * @returns {boolean} - result of test\n*/\nfunction isEmpty(value) {\n  return (getLength(value) === 0);\n}\n\n/*\n * Get property value of object\n * @param object {*} - object\n * @returns {*} - property value\n*/\nfunction getValue(object) {\n  for (var i = 1; i < arguments.length && isValue(object); ++i) {\n    var propertyName = arguments[i];\n    assert(typeof propertyName === 'string');\n    object = object[propertyName];\n  }\n  return object;\n}\n\n/*\n * Convert string values into the proper type.\n * @param value {*} - value to convert\n * @param skipError {boolean} - skip error during conversion\n * @returns {*} - transformed model object\n * @throws {SwaggerConverterError}\n*/\nfunction fixNonStringValue(value, skipError) {\n  if (typeof value !== 'string') {\n    return value;\n  }\n\n  if (value === '') {\n    return undefined;\n  }\n\n  var lcValue = value.toLowerCase();\n\n  if (lcValue === 'true') {\n    return true;\n  }\n  if (lcValue === 'false') {\n    return false;\n  }\n\n  try {\n    return JSON.parse(value);\n  } catch (e) {\n    //TODO: report warning\n    if (skipError === true) {\n      return undefined;\n    }\n\n    throw new SwaggerConverterError('incorect property value: ' + e.message);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-swagger/node_modules/swagger/lib/util/spec.js":"/****************************************************************************\n Copyright 2015 Apigee Corporation\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n ****************************************************************************/\n'use strict';\n\nvar emit = require('./feedback').emit;\nvar swaggerSpec = require('swagger-tools').specs.v2_0;\n\nmodule.exports = {\n  validateSwagger: validateSwagger\n};\n\nfunction validateSwagger(swagger, options, cb) {\n\n  swaggerSpec.validate(swagger, function(err, results) {\n    if (err) { return cb(err); }\n\n    var toJsonPointer = function (path) {\n      // http://tools.ietf.org/html/rfc6901#section-4\n      return '#/' + path.map(function (part) {\n          return part.replace(/\\//g, '~1');\n        }).join('/');\n    };\n\n    if (results) {\n      if (options.json) {\n        cb(null, JSON.stringify(results, null, '  '));\n      } else {\n        if (results.errors.length > 0) {\n          emit('\\nProject Errors');\n          emit('--------------');\n\n          results.errors.forEach(function (vErr) {\n            emit(toJsonPointer(vErr.path) + ': ' + vErr.message);\n          });\n        }\n\n        if (results.warnings.length > 0) {\n          emit('\\nProject Warnings');\n          emit('----------------');\n\n          results.warnings.forEach(function (vWarn) {\n            emit(toJsonPointer(vWarn.path) + ': ' + vWarn.message);\n          });\n        }\n\n        cb(null, 'Results: ' + results.errors.length + ' errors, ' + results.warnings.length + ' warnings');\n      }\n    } else {\n      if (options.json) {\n        cb(null, '');\n      } else {\n        cb(null, 'Results: 0 errors, 0 warnings');\n      }\n    }\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-swagger/node_modules/swagger-tools/index.js":"/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014 Apigee Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n'use strict';\n\nvar _ = require('lodash-compat');\nvar debug = require('debug')('swagger-tools:middleware');\nvar helpers = require('./lib/helpers');\n\nvar initializeMiddleware = function initializeMiddleware (rlOrSO, resources, callback) {\n  var args;\n  var spec;\n\n  debug('Initializing middleware');\n\n  if (_.isUndefined(rlOrSO)) {\n    throw new Error('rlOrSO is required');\n  } else if (!_.isPlainObject(rlOrSO)) {\n    throw new TypeError('rlOrSO must be an object');\n  }\n\n  args = [rlOrSO];\n  spec = helpers.getSpec(helpers.getSwaggerVersion(rlOrSO), true);\n\n  debug('  Identified Swagger version: %s', spec.version);\n\n  if (spec.version === '1.2') {\n    if (_.isUndefined(resources)) {\n      throw new Error('resources is required');\n    } else if (!_.isArray(resources)) {\n      throw new TypeError('resources must be an array');\n    }\n\n    debug('  Number of API Declarations: %d', resources.length);\n\n    args.push(resources);\n  } else {\n    callback = arguments[1];\n  }\n\n  if (_.isUndefined(callback)) {\n    throw new Error('callback is required');\n  } else if (!_.isFunction(callback)) {\n    throw new TypeError('callback must be a function');\n  }\n\n  args.push(function (err, results) {\n    if (results && results.errors.length + _.reduce(results.apiDeclarations || [], function (count, apiDeclaration) {\n      return count += (apiDeclaration ? apiDeclaration.errors.length : 0);\n    }, 0) > 0) {\n      err = new Error('Swagger document(s) failed validation so the server cannot start');\n\n      err.results = results;\n    }\n\n    debug('  Validation: %s', err ? 'failed' : 'succeeded');\n\n    try {\n      if (err) {\n        throw err;\n      }\n\n      callback({\n        // Create a wrapper to avoid having to pass the non-optional arguments back to the swaggerMetadata middleware\n        swaggerMetadata: function () {\n          var swaggerMetadata = require('./middleware/swagger-metadata');\n\n          return swaggerMetadata.apply(undefined, args.slice(0, args.length - 1));\n        },\n        swaggerRouter: require('./middleware/swagger-router'),\n        swaggerSecurity: require('./middleware/swagger-security'),\n        // Create a wrapper to avoid having to pass the non-optional arguments back to the swaggerUi middleware\n        swaggerUi: function (options) {\n          var swaggerUi = require('./middleware/swagger-ui');\n          var suArgs = [rlOrSO];\n\n          if (spec.version === '1.2') {\n            suArgs.push(_.reduce(resources, function (map, resource) {\n              map[resource.resourcePath] = resource;\n\n              return map;\n            }, {}));\n          }\n\n          suArgs.push(options || {});\n\n          return swaggerUi.apply(undefined, suArgs);\n        },\n        swaggerValidator: require('./middleware/swagger-validator')\n      });\n    } catch (err) {\n      if (process.env.RUNNING_SWAGGER_TOOLS_TESTS === 'true') {\n        // When running the swagger-tools test suite, we want to return an error instead of exiting the process.  This\n        // does not mean that this function is an error-first callback but due to json-refs using Promises, we have to\n        // return the error to avoid the error being swallowed.\n        callback(err);\n      } else {\n        if (err.failedValidation === true) {\n          helpers.printValidationResults(spec.version, rlOrSO, resources, results, true);\n        } else {\n          console.error('Error initializing middleware');\n          console.error(err.stack);\n        }\n\n        process.exit(1);\n      }\n    }\n  });\n\n  spec.validate.apply(spec, args);\n};\n\nmodule.exports = {\n  initializeMiddleware: initializeMiddleware,\n  specs: require('./lib/specs')\n};\n","/home/travis/build/npmtest/node-npmtest-swagger/node_modules/swagger-tools/lib/helpers.js":"/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014 Apigee Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n'use strict';\n\n// Done this way to make the Browserify build smaller\nvar _ = {\n  each: require('lodash-compat/collection/each'),\n  indexOf: require('lodash-compat/array/indexOf'),\n  isArray: require('lodash-compat/lang/isArray'),\n  isPlainObject: require('lodash-compat/lang/isPlainObject'),\n  isString: require('lodash-compat/lang/isString'),\n  isUndefined: require('lodash-compat/lang/isUndefined'),\n  reduce: require('lodash-compat/collection/reduce')\n};\nvar JsonRefs = require('json-refs');\nvar traverse = require('traverse');\nvar ZSchema = require('z-schema');\n\nvar customJsonSchemaFormats = ['byte', 'double', 'float', 'int32', 'int64', 'mime-type', 'uri-template'];\nvar draft04Json = require('../schemas/json-schema-draft-04.json');\nvar draft04Url = 'http://json-schema.org/draft-04/schema';\nvar specCache = {};\n\nmodule.exports.registerCustomFormats = function (json) {\n  traverse(json).forEach(function () {\n    var name = this.key;\n    var format = this.node;\n\n    if (name === 'format' && _.indexOf(ZSchema.getRegisteredFormats(), format) === -1) {\n      ZSchema.registerFormat(format, function () {\n        return true;\n      });\n    }\n  });\n};\n\nmodule.exports.createJsonValidator = function (schemas) {\n  var validator = new ZSchema({\n    breakOnFirstError: false,\n    reportPathAsArray: true\n  });\n  var result;\n\n  // Add the draft-04 spec\n  validator.setRemoteReference(draft04Url, draft04Json);\n\n  // Swagger uses some unsupported/invalid formats so just make them all pass\n  _.each(customJsonSchemaFormats, function (format) {\n    ZSchema.registerFormat(format, function () {\n      return true;\n    });\n  });\n\n  // Compile and validate the schemas\n  if (!_.isUndefined(schemas)) {\n    result = validator.compileSchema(schemas);\n\n    // If there is an error, it's unrecoverable so just blow the eff up\n    if (result === false) {\n      console.error('JSON Schema file' + (schemas.length > 1 ? 's are' : ' is') + ' invalid:');\n\n      _.each(validator.getLastErrors(), function (err) {\n        console.error('  ' + (_.isArray(err.path) ? JsonRefs.pathToPtr(err.path) : err.path) + ': ' + err.message);\n      });\n\n      throw new Error('Unable to create validator due to invalid JSON Schema');\n    }\n  }\n\n  return validator;\n};\n\nmodule.exports.formatResults = function (results) {\n  if (results) {\n    // Update the results based on its content to indicate success/failure accordingly\n    results = (results.errors.length + results.warnings.length +\n    _.reduce(results.apiDeclarations, function (count, aResult) {\n      if (aResult) {\n        count += aResult.errors.length + aResult.warnings.length;\n      }\n\n      return count;\n    }, 0) > 0) ? results : undefined;\n  }\n\n  return results;\n};\n\nvar getErrorCount = module.exports.getErrorCount = function (results) {\n  var errors = 0;\n\n  if (results) {\n    errors = results.errors.length;\n\n    _.each(results.apiDeclarations, function (adResults) {\n      if (adResults) {\n        errors += adResults.errors.length;\n      }\n    });\n  }\n\n  return errors;\n};\n\nvar coerceVersion = function (version) {\n  // Convert the version to a number (Required for helpers.getSpec)\n  if (version && !_.isString(version)) {\n    version = version.toString();\n\n    // Handle rounding issues (Only required for when Swagger version ends in '.0')\n    if (version.indexOf('.') === -1) {\n      version += '.0';\n    }\n  }\n\n  return version;\n};\n\n/**\n * Returns the proper specification based on the human readable version.\n *\n * @param {string} version - The human readable Swagger version (Ex: 1.2)\n * @param {[boolean=false]} throwError - Throw an error if the version could not be identified\n *\n * @returns the corresponding Swagger Specification object or undefined if there is none\n */\nmodule.exports.getSpec = function (version, throwError) {\n  var spec;\n\n  version = coerceVersion(version);\n  spec = specCache[version];\n\n  if (_.isUndefined(spec)) {\n    switch (version) {\n    case '1.2':\n      spec = require('../lib/specs').v1_2; // jshint ignore:line\n\n      break;\n\n    case '2.0':\n      spec = require('../lib/specs').v2_0; // jshint ignore:line\n\n      break;\n\n    default:\n      if (throwError === true) {\n        throw new Error('Unsupported Swagger version: ' + version);\n      }\n    }\n  }\n\n  return spec;\n};\n\n/**\n * Atempts to figure out the Swagger version from the Swagger document.\n *\n * @param {object} document - The Swagger document\n *\n * @returns the Swagger version or undefined if the document is not a Swagger document\n */\nmodule.exports.getSwaggerVersion = function (document) {\n  return _.isPlainObject(document) ? coerceVersion(document.swaggerVersion || document.swagger) : undefined;\n};\n\nmodule.exports.printValidationResults = function (version, apiDOrSO, apiDeclarations, results, printSummary) {\n  var hasErrors = getErrorCount(results) > 0;\n  var stream = hasErrors ? console.error : console.log;\n  var pluralize = function (string, count) {\n    return count === 1 ? string : string + 's';\n  };\n  var printErrorsOrWarnings = function (header, entries, indent) {\n    if (header) {\n      stream(header + ':');\n      stream();\n    }\n\n    _.each(entries, function (entry) {\n      stream(new Array(indent + 1).join(' ') + JsonRefs.pathToPtr(entry.path) + ': ' + entry.message);\n\n      if (entry.inner) {\n        printErrorsOrWarnings (undefined, entry.inner, indent + 2);\n      }\n    });\n\n    if (header) {\n      stream();\n    }\n  };\n  var errorCount = 0;\n  var warningCount = 0;\n\n  stream();\n\n  if (results.errors.length > 0) {\n    errorCount += results.errors.length;\n\n    printErrorsOrWarnings('API Errors', results.errors, 2);\n  }\n\n  if (results.warnings.length > 0) {\n    warningCount += results.warnings.length;\n\n    printErrorsOrWarnings('API Warnings', results.warnings, 2);\n  }\n\n  if (results.apiDeclarations) {\n    results.apiDeclarations.forEach(function (adResult, index) {\n      if (!adResult) {\n        return;\n      }\n\n      var name = apiDeclarations[index].resourcePath || index;\n\n      if (adResult.errors.length > 0) {\n        errorCount += adResult.errors.length;\n\n        printErrorsOrWarnings('  API Declaration (' + name + ') Errors', adResult.errors, 4);\n      }\n\n      if (adResult.warnings.length > 0) {\n        warningCount += adResult.warnings.length;\n\n        printErrorsOrWarnings('  API Declaration (' + name + ') Warnings', adResult.warnings, 4);\n      }\n    });\n  }\n\n  if (printSummary) {\n    if (errorCount > 0) {\n      stream(errorCount + ' ' + pluralize('error', errorCount) + ' and ' + warningCount + ' ' +\n                    pluralize('warning', warningCount));\n    } else {\n      stream('Validation succeeded but with ' + warningCount + ' ' + pluralize('warning', warningCount));\n    }\n  }\n\n  stream();\n};\n\nmodule.exports.swaggerOperationMethods = [\n  'DELETE',\n  'GET',\n  'HEAD',\n  'OPTIONS',\n  'PATCH',\n  'POST',\n  'PUT'\n];\n","/home/travis/build/npmtest/node-npmtest-swagger/node_modules/swagger-tools/lib/specs.js":"/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014 Apigee Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n'use strict';\n\n// Done this way to make the Browserify build smaller\nvar _ = {\n  cloneDeep: require('lodash-compat/lang/cloneDeep'),\n  difference: require('lodash-compat/array/difference'),\n  each: require('lodash-compat/collection/each'),\n  find: require('lodash-compat/collection/find'),\n  has: require('lodash-compat/object/has'),\n  isArray: require('lodash-compat/lang/isArray'),\n  isFunction: require('lodash-compat/lang/isFunction'),\n  isPlainObject: require('lodash-compat/lang/isPlainObject'),\n  isString: require('lodash-compat/lang/isString'),\n  isUndefined: require('lodash-compat/lang/isUndefined'),\n  map: require('lodash-compat/collection/map'),\n  reduce: require('lodash-compat/collection/reduce'),\n  set: require('lodash-compat/object/set'),\n  union: require('lodash-compat/array/union')\n};\nvar async = require('async');\nvar helpers = require('./helpers');\nvar JsonRefs = require('json-refs');\nvar SparkMD5 = require('spark-md5');\nvar swaggerConverter = require('swagger-converter');\nvar traverse = require('traverse');\nvar validators = require('./validators');\nvar YAML = require('js-yaml');\n\n// Work around swagger-converter packaging issue (Browser builds only)\nif (_.isPlainObject(swaggerConverter)) {\n  swaggerConverter = global.SwaggerConverter.convert;\n}\n\nvar documentCache = {};\n\nvar sanitizeRef = function (version, ref) {\n  return version !== '1.2' ? ref : ref.replace('#/models/', '');\n};\n\nvar swagger1RefPreProcesor = function (obj) {\n  var pObj = _.cloneDeep(obj);\n\n  pObj.$ref = '#/models/' + obj.$ref;\n\n  return pObj;\n};\nvar validOptionNames = _.map(helpers.swaggerOperationMethods, function (method) {\n  return method.toLowerCase();\n});\n\nvar isRemotePtr = function (refDetails) {\n  return ['relative', 'remote'].indexOf(refDetails.type) > -1;\n};\n\nvar createErrorOrWarning = function (code, message, path, dest) {\n  dest.push({\n    code: code,\n    message: message,\n    path: path\n  });\n};\n\nvar addReference = function (cacheEntry, defPathOrPtr, refPathOrPtr, results, omitError) {\n  var result = true;\n  var swaggerVersion = helpers.getSwaggerVersion(cacheEntry.resolved);\n  var defPath = _.isArray(defPathOrPtr) ? defPathOrPtr : JsonRefs.pathFromPtr(defPathOrPtr);\n  var defPtr = _.isArray(defPathOrPtr) ? JsonRefs.pathToPtr(defPathOrPtr) : defPathOrPtr;\n  var refPath = _.isArray(refPathOrPtr) ? refPathOrPtr : JsonRefs.pathFromPtr(refPathOrPtr);\n  var refPtr = _.isArray(refPathOrPtr) ? JsonRefs.pathToPtr(refPathOrPtr) : refPathOrPtr;\n  var code;\n  var def;\n  var displayId;\n  var i;\n  var msgPrefix;\n  var type;\n\n  def = cacheEntry.definitions[defPtr];\n  type = defPath[0];\n  code = type === 'securityDefinitions' ?\n    'SECURITY_DEFINITION' :\n    type.substring(0, type.length - 1).toUpperCase();\n  displayId = swaggerVersion === '1.2' ? defPath[defPath.length - 1] : defPtr;\n  msgPrefix = type === 'securityDefinitions' ?\n    'Security definition' :\n    code.charAt(0) + code.substring(1).toLowerCase();\n\n  // This is an authorization scope reference\n  if (['authorizations', 'securityDefinitions'].indexOf(defPath[0]) > -1 && defPath[2] === 'scopes') {\n    code += '_SCOPE';\n    msgPrefix += ' scope';\n  }\n\n  // If the reference was not found and this is not an authorization/security scope reference, attempt to find a\n  // parent object to add the reference too.  (Issue 176)\n  if (_.isUndefined(def) && ['AUTHORIZATION_SCOPE', 'SECURITY_DEFINITION_SCOPE'].indexOf(code) === -1) {\n    // Attempt to find the definition in case the reference is to a path within a definition`\n    for (i = 1; i < defPath.length; i++) {\n      var pPath = defPath.slice(0, defPath.length - i);\n      var pPtr = JsonRefs.pathToPtr(pPath);\n      var pDef = cacheEntry.definitions[pPtr];\n\n      if (!_.isUndefined(pDef)) {\n        def = pDef;\n\n        break;\n      }\n    }\n  }\n\n  if (_.isUndefined(def)) {\n    if (!omitError) {\n      if (cacheEntry.swaggerVersion !== '1.2' && ['SECURITY_DEFINITION', 'SECURITY_DEFINITION_SCOPE'].indexOf(code) === -1) {\n        refPath.push('$ref');\n      }\n\n      createErrorOrWarning('UNRESOLVABLE_' + code, msgPrefix + ' could not be resolved: ' + displayId, refPath,\n                           results.errors);\n    }\n\n    result = false;\n  } else {\n    if (_.isUndefined(def.references)) {\n      def.references = [];\n    }\n\n    def.references.push(refPtr);\n  }\n\n  return result;\n};\n\nvar getOrComposeSchema = function (documentMetadata, modelId) {\n  var title = 'Composed ' + (documentMetadata.swaggerVersion === '1.2' ?\n                               JsonRefs.pathFromPtr(modelId).pop() :\n                               modelId);\n  var metadata = documentMetadata.definitions[modelId];\n  var originalT = traverse(documentMetadata.original);\n  var resolvedT = traverse(documentMetadata.resolved);\n  var composed;\n  var original;\n\n  if (!metadata) {\n    return undefined;\n  }\n\n  original = _.cloneDeep(originalT.get(JsonRefs.pathFromPtr(modelId)));\n  composed = _.cloneDeep(resolvedT.get(JsonRefs.pathFromPtr(modelId)));\n\n  // Convert the Swagger 1.2 document to a valid JSON Schema file\n  if (documentMetadata.swaggerVersion === '1.2') {\n    // Create inheritance model\n    if (metadata.lineage.length > 0) {\n      composed.allOf = [];\n\n      _.each(metadata.lineage, function (modelId) {\n        composed.allOf.push(getOrComposeSchema(documentMetadata, modelId));\n      });\n    }\n\n    // Remove the subTypes property\n    delete composed.subTypes;\n\n    _.each(composed.properties, function (property, name) {\n      var oProp = original.properties[name];\n\n      // Convert the string values to numerical values\n      _.each(['maximum', 'minimum'], function (prop) {\n        if (_.isString(property[prop])) {\n          property[prop] = parseFloat(property[prop]);\n        }\n      });\n\n      _.each(JsonRefs.findRefs(oProp, {\n        includeInvalid: true,\n        refPreProcessor: swagger1RefPreProcesor\n      }), function (refDetails, refPtr) {\n        var dMetadata = documentMetadata.definitions[refDetails.uri];\n        var path = JsonRefs.pathFromPtr(refPtr);\n\n        if (dMetadata.lineage.length > 0) {\n          traverse(property).set(path, getOrComposeSchema(documentMetadata, refDetails.uri));\n        } else {\n          traverse(property).set(path.concat('title'), 'Composed ' + sanitizeRef(documentMetadata.swaggerVersion,\n                                                                                 refDetails.uri));\n        }\n      });\n    });\n  }\n\n  // Scrub id properties\n  composed = traverse(composed).map(function (val) {\n    if (this.key === 'id' && _.isString(val)) {\n      this.remove();\n    }\n  });\n\n  composed.title = title;\n\n  return composed;\n};\n\nvar createUnusedErrorOrWarning = function (val, codeSuffix, msgPrefix, path, dest) {\n  createErrorOrWarning('UNUSED_' + codeSuffix, msgPrefix + ' is defined but is not used: ' + val, path, dest);\n};\n\nvar getDocumentCache = function (apiDOrSO) {\n  var key = SparkMD5.hash(JSON.stringify(apiDOrSO));\n  var cacheEntry = documentCache[key] || _.find(documentCache, function (cacheEntry) {\n    return cacheEntry.resolvedId === key;\n  });\n\n  if (!cacheEntry) {\n    cacheEntry = documentCache[key] = {\n      definitions: {},\n      original: apiDOrSO,\n      resolved: undefined,\n      swaggerVersion: helpers.getSwaggerVersion(apiDOrSO)\n    };\n  }\n\n  return cacheEntry;\n};\n\nvar handleValidationError = function (results, callback) {\n  var err = new Error('The Swagger document(s) are invalid');\n\n  err.errors = results.errors;\n  err.failedValidation = true;\n  err.warnings = results.warnings;\n\n  if (results.apiDeclarations) {\n    err.apiDeclarations = results.apiDeclarations;\n  }\n\n  callback(err);\n};\n\nvar normalizePath = function (path) {\n  var matches = path.match(/\\{(.*?)\\}/g);\n  var argNames = [];\n  var normPath = path;\n\n  if (matches) {\n    _.each(matches, function (match, index) {\n      normPath = normPath.replace(match, '{' + index + '}');\n      argNames.push(match.replace(/[{}]/g, ''));\n    });\n  }\n\n  return {\n    path: normPath,\n    args: argNames\n  };\n};\n\nvar removeCirculars = function (obj) {\n  function walk (ancestors, node, path) {\n    function walkItem (item, segment) {\n      path.push(segment);\n      walk(ancestors, item, path);\n      path.pop();\n    }\n\n    // We do not process circular objects again\n    if (ancestors.indexOf(node) === -1) {\n      ancestors.push(node);\n\n      if (_.isArray(node) || _.isPlainObject(node)) {\n        _.each(node, function (member, indexOrKey) {\n          walkItem(member, indexOrKey.toString());\n        });\n      }\n    } else {\n      _.set(obj, path, {});\n    }\n\n    ancestors.pop();\n  }\n\n  walk([], obj, []);\n};\n\n\nvar validateNoExist = function (data, val, codeSuffix, msgPrefix, path, dest) {\n  if (!_.isUndefined(data) && data.indexOf(val) > -1) {\n    createErrorOrWarning('DUPLICATE_' + codeSuffix, msgPrefix + ' already defined: ' + val, path, dest);\n  }\n};\n\nvar validateSchemaConstraints = function (documentMetadata, schema, path, results, skip) {\n  try {\n    validators.validateSchemaConstraints(documentMetadata.swaggerVersion, schema, path, undefined);\n  } catch (err) {\n    if (!skip) {\n      createErrorOrWarning(err.code, err.message, err.path, results.errors);\n    }\n  }\n};\n\nvar processDocument = function (documentMetadata, results) {\n  var swaggerVersion = documentMetadata.swaggerVersion;\n  var getDefinitionMetadata = function (defPath, inline) {\n    var defPtr = JsonRefs.pathToPtr(defPath);\n    var metadata = documentMetadata.definitions[defPtr];\n\n    if (!metadata) {\n      metadata = documentMetadata.definitions[defPtr] = {\n        inline: inline || false,\n        references: []\n      };\n\n      // For model definitions, add the inheritance properties\n      if (['definitions', 'models'].indexOf(JsonRefs.pathFromPtr(defPtr)[0]) > -1) {\n        metadata.cyclical = false;\n        metadata.lineage = undefined;\n        metadata.parents = [];\n      }\n    }\n\n    return metadata;\n  };\n  var getDisplayId = function (id) {\n    return swaggerVersion === '1.2' ? JsonRefs.pathFromPtr(id).pop() : id;\n  };\n  var jsonRefsOptions = {\n    filter: 'local',\n    includeInvalid: true\n  };\n  var walk = function (root, id, lineage) {\n    var definition = documentMetadata.definitions[id || root];\n\n    if (definition) {\n      _.each(definition.parents, function (parent) {\n        lineage.push(parent);\n\n        if (root !== parent) {\n          walk(root, parent, lineage);\n        }\n      });\n    }\n  };\n  var authDefsProp = swaggerVersion === '1.2' ? 'authorizations' : 'securityDefinitions';\n  var modelDefsProp = swaggerVersion === '1.2' ? 'models' : 'definitions';\n\n  // Process authorization definitions\n  _.each(documentMetadata.resolved[authDefsProp], function (authorization, name) {\n    var securityDefPath = [authDefsProp, name];\n\n    // Swagger 1.2 only has authorization definitions in the Resource Listing\n    if (swaggerVersion === '1.2' && !authorization.type) {\n      return;\n    }\n\n    // Create the authorization definition metadata\n    getDefinitionMetadata(securityDefPath);\n\n    _.reduce(authorization.scopes, function (seenScopes, scope, indexOrName) {\n      var scopeName = swaggerVersion === '1.2' ? scope.scope : indexOrName;\n      var scopeDefPath = securityDefPath.concat(['scopes', indexOrName.toString()]);\n      var scopeMetadata = getDefinitionMetadata(securityDefPath.concat(['scopes', scopeName]));\n\n      scopeMetadata.scopePath = scopeDefPath;\n\n      // Identify duplicate authorization scope defined in the Resource Listing\n      validateNoExist(seenScopes, scopeName, 'AUTHORIZATION_SCOPE_DEFINITION', 'Authorization scope definition',\n                      swaggerVersion === '1.2' ? scopeDefPath.concat('scope') : scopeDefPath, results.warnings);\n\n      seenScopes.push(scopeName);\n\n      return seenScopes;\n    }, []);\n  });\n\n  // Process model definitions\n  _.each(documentMetadata.resolved[modelDefsProp], function (model, modelId) {\n    var modelDefPath = [modelDefsProp, modelId];\n    var modelMetadata = getDefinitionMetadata(modelDefPath);\n\n    // Identify model id mismatch (Id in models object is not the same as the model's id in the models object)\n    if (swaggerVersion === '1.2' && modelId !== model.id) {\n      createErrorOrWarning('MODEL_ID_MISMATCH', 'Model id does not match id in models object: ' + model.id,\n                           modelDefPath.concat('id'), results.errors);\n    }\n\n    // Do not reprocess parents/references if already processed\n    if (_.isUndefined(modelMetadata.lineage)) {\n      // Handle inheritance references\n      switch (swaggerVersion) {\n      case '1.2':\n        _.each(model.subTypes, function (subType, index) {\n          var subPath = ['models', subType];\n          var subPtr = JsonRefs.pathToPtr(subPath);\n          var subMetadata = documentMetadata.definitions[subPtr];\n          var refPath = modelDefPath.concat(['subTypes', index.toString()]);\n\n          // If the metadata does not yet exist, create it\n          if (!subMetadata && documentMetadata.resolved[modelDefsProp][subType]) {\n            subMetadata = getDefinitionMetadata(subPath);\n          }\n\n          // If the reference is valid, add the parent\n          if (addReference(documentMetadata, subPath, refPath, results)) {\n            subMetadata.parents.push(JsonRefs.pathToPtr(modelDefPath));\n          }\n        });\n\n        break;\n\n      default:\n        _.each(documentMetadata.original[modelDefsProp][modelId].allOf, function (schema, index) {\n          var isInline = false;\n          var parentPath;\n\n          if (_.isUndefined(schema.$ref) || isRemotePtr(JsonRefs.getRefDetails(schema))) {\n            isInline = true;\n            parentPath = modelDefPath.concat(['allOf', index.toString()]);\n          } else {\n            parentPath = JsonRefs.pathFromPtr(schema.$ref);\n          }\n\n          // If the parent model does not exist, do not create its metadata\n          if (!_.isUndefined(traverse(documentMetadata.resolved).get(parentPath))) {\n            // Create metadata for parent\n            getDefinitionMetadata(parentPath, isInline);\n\n            modelMetadata.parents.push(JsonRefs.pathToPtr(parentPath));\n          }\n        });\n\n        break;\n      }\n    }\n  });\n\n  switch (swaggerVersion) {\n  case '2.0':\n    // Process parameter definitions\n    _.each(documentMetadata.resolved.parameters, function (parameter, name) {\n      var path = ['parameters', name];\n\n      getDefinitionMetadata(path);\n\n      validateSchemaConstraints(documentMetadata, parameter, path, results);\n    });\n\n    // Process response definitions\n    _.each(documentMetadata.resolved.responses, function (response, name) {\n      var path = ['responses', name];\n\n      getDefinitionMetadata(path);\n\n      validateSchemaConstraints(documentMetadata, response, path, results);\n    });\n\n    break;\n  }\n\n  // Validate definition/models (Inheritance, property definitions, ...)\n  _.each(documentMetadata.definitions, function (metadata, id) {\n    var defPath = JsonRefs.pathFromPtr(id);\n    var definition = traverse(documentMetadata.original).get(defPath);\n    var defProp = defPath[0];\n    var code = defProp.substring(0, defProp.length - 1).toUpperCase();\n    var msgPrefix = code.charAt(0) + code.substring(1).toLowerCase();\n    var dProperties;\n    var iProperties;\n    var lineage;\n\n    // The only checks we perform below are inheritance checks so skip all non-model definitions\n    if (['definitions', 'models'].indexOf(defProp) === -1) {\n      return;\n    }\n\n    dProperties = [];\n    iProperties = [];\n    lineage = metadata.lineage;\n\n    // Do not reprocess lineage if already processed\n    if (_.isUndefined(lineage)) {\n      lineage = [];\n\n      walk(id, undefined, lineage);\n\n      // Root > next > ...\n      lineage.reverse();\n\n      metadata.lineage = _.cloneDeep(lineage);\n\n      metadata.cyclical = lineage.length > 1 && lineage[0] === id;\n    }\n\n    // Swagger 1.2 does not allow multiple inheritance while Swagger 2.0+ does\n    if (metadata.parents.length > 1 && swaggerVersion === '1.2') {\n      createErrorOrWarning('MULTIPLE_' + code + '_INHERITANCE',\n                           'Child ' + code.toLowerCase() + ' is sub type of multiple models: ' +\n                           _.map(metadata.parents, function (parent) {\n                             return getDisplayId(parent);\n                           }).join(' && '), defPath, results.errors);\n    }\n\n    if (metadata.cyclical) {\n      createErrorOrWarning('CYCLICAL_' + code + '_INHERITANCE',\n                           msgPrefix + ' has a circular inheritance: ' +\n                             _.map(lineage, function (dep) {\n                               return getDisplayId(dep);\n                             }).join(' -> ') + ' -> ' + getDisplayId(id),\n                            defPath.concat(swaggerVersion === '1.2' ? 'subTypes' : 'allOf'), results.errors);\n    }\n\n    // Remove self reference from the end of the lineage (Front too if cyclical)\n    _.each(lineage.slice(metadata.cyclical ? 1 : 0), function (id) {\n      var pModel = traverse(documentMetadata.resolved).get(JsonRefs.pathFromPtr(id));\n\n      _.each(Object.keys(pModel.properties || {}), function (name) {\n        if (iProperties.indexOf(name) === -1) {\n          iProperties.push(name);\n        }\n      });\n    });\n\n    // Validate simple definitions\n    validateSchemaConstraints(documentMetadata, definition, defPath, results);\n\n    // Identify redeclared properties\n    _.each(definition.properties, function (property, name) {\n      var pPath = defPath.concat(['properties', name]);\n\n      // Do not process unresolved properties\n      if (!_.isUndefined(property)) {\n        validateSchemaConstraints(documentMetadata, property, pPath, results);\n\n        if (iProperties.indexOf(name) > -1) {\n          createErrorOrWarning('CHILD_' + code + '_REDECLARES_PROPERTY',\n                               'Child ' + code.toLowerCase() + ' declares property already declared by ancestor: ' +\n                               name,\n                               pPath, results.errors);\n        } else {\n          dProperties.push(name);\n        }\n      }\n    });\n\n    // Identify missing required properties\n    _.each(definition.required || [], function (name, index) {\n      var type = swaggerVersion === '1.2' ? 'Model' : 'Definition';\n\n      if (iProperties.indexOf(name) === -1 && dProperties.indexOf(name) === -1) {\n        createErrorOrWarning('MISSING_REQUIRED_' + type.toUpperCase() + '_PROPERTY',\n                             type + ' requires property but it is not defined: ' + name,\n                             defPath.concat(['required', index.toString()]), results.errors);\n      }\n    });\n  });\n\n  if (documentMetadata.swaggerVersion === '1.2') {\n    jsonRefsOptions.refPreProcessor = swagger1RefPreProcesor;\n  }\n\n  // Process local references\n  _.each(JsonRefs.findRefs(documentMetadata.original, jsonRefsOptions), function (refDetails, refPtr) {\n    addReference(documentMetadata, refDetails.uri, refPtr, results);\n  });\n\n  // Process invalid references\n  _.each(documentMetadata.referencesMetadata, function (refDetails, refPtr) {\n    if (isRemotePtr(refDetails) && refDetails.missing === true) {\n      results.errors.push({\n        code: 'UNRESOLVABLE_REFERENCE',\n        message: 'Reference could not be resolved: ' + sanitizeRef(documentMetadata.swaggerVersion, refDetails.uri),\n        path: JsonRefs.pathFromPtr(refPtr).concat('$ref')\n      });\n    }\n  });\n};\n\nvar validateExist = function (data, val, codeSuffix, msgPrefix, path, dest) {\n  if (!_.isUndefined(data) && data.indexOf(val) === -1) {\n    createErrorOrWarning('UNRESOLVABLE_' + codeSuffix, msgPrefix + ' could not be resolved: ' + val, path, dest);\n  }\n};\n\nvar processAuthRefs = function (documentMetadata, authRefs, path, results) {\n  var code = documentMetadata.swaggerVersion === '1.2' ? 'AUTHORIZATION' : 'SECURITY_DEFINITION';\n  var msgPrefix = code === 'AUTHORIZATION' ? 'Authorization' : 'Security definition';\n\n  if (documentMetadata.swaggerVersion === '1.2') {\n    _.reduce(authRefs, function (seenNames, scopes, name) {\n      var authPtr = ['authorizations', name];\n      var aPath = path.concat([name]);\n\n      // Add reference or record unresolved authorization\n      if (addReference(documentMetadata, authPtr, aPath, results)) {\n        _.reduce(scopes, function (seenScopes, scope, index) {\n          var sPath = aPath.concat(index.toString(), 'scope');\n          var sPtr = authPtr.concat(['scopes', scope.scope]);\n\n          validateNoExist(seenScopes, scope.scope, code + '_SCOPE_REFERENCE', msgPrefix + ' scope reference', sPath,\n                          results.warnings);\n\n          // Add reference or record unresolved authorization scope\n          addReference(documentMetadata, sPtr, sPath, results);\n\n          return seenScopes.concat(scope.scope);\n        }, []);\n      }\n\n      return seenNames.concat(name);\n    }, []);\n  } else {\n    _.reduce(authRefs, function (seenNames, scopes, index) {\n      _.each(scopes, function (scopes, name) {\n        var authPtr = ['securityDefinitions', name];\n        var authRefPath = path.concat(index.toString(), name);\n\n        // Ensure the security definition isn't referenced more than once (Swagger 2.0+)\n        validateNoExist(seenNames, name, code + '_REFERENCE', msgPrefix + ' reference', authRefPath,\n                        results.warnings);\n\n        seenNames.push(name);\n\n        // Add reference or record unresolved authorization\n        if (addReference(documentMetadata, authPtr, authRefPath, results)) {\n          _.each(scopes, function (scope, index) {\n            // Add reference or record unresolved authorization scope\n            var sPtr = authPtr.concat(['scopes', scope]);\n            addReference(documentMetadata, sPtr, authRefPath.concat(index.toString()),\n                         results);\n          });\n        }\n      });\n\n      return seenNames;\n    }, []);\n  }\n};\n\nvar resolveRefs = function (apiDOrSO, callback) {\n  var cacheEntry = getDocumentCache(apiDOrSO);\n  var swaggerVersion = helpers.getSwaggerVersion(apiDOrSO);\n  var jsonRefsOptions = {\n    includeInvalid: true,\n    loaderOptions: {\n      processContent: function (res, callback) {\n        callback(undefined, YAML.safeLoad(res.text));\n      }\n    }\n  };\n\n  if (!cacheEntry.resolved) {\n    // For Swagger 1.2, we have to create real JSON References\n    if (swaggerVersion === '1.2') {\n      jsonRefsOptions.refPreProcessor = swagger1RefPreProcesor;\n    }\n\n    // Resolve references\n    JsonRefs.resolveRefs(apiDOrSO, jsonRefsOptions)\n      .then(function (results) {\n        removeCirculars(results.resolved);\n\n        // Fix circular references\n        _.each(results.refs, function (refDetails, refPtr) {\n          if (refDetails.circular) {\n            _.set(results.resolved, JsonRefs.pathFromPtr(refPtr), {});\n          }\n        });\n\n        cacheEntry.referencesMetadata = results.refs;\n        cacheEntry.resolved = results.resolved;\n        cacheEntry.resolvedId = SparkMD5.hash(JSON.stringify(results.resolved));\n\n        callback();\n      })\n      .catch(callback);\n  } else {\n    callback();\n  }\n};\n\nvar validateAgainstSchema = function (spec, schemaOrName, data, callback) {\n  var validator = _.isString(schemaOrName) ? spec.validators[schemaOrName] : helpers.createJsonValidator();\n\n  helpers.registerCustomFormats(data);\n\n  try {\n    validators.validateAgainstSchema(schemaOrName, data, validator);\n  } catch (err) {\n    if (err.failedValidation) {\n      return callback(undefined, err.results);\n    } else {\n      return callback(err);\n    }\n  }\n\n  resolveRefs(data, function (err) {\n    return callback(err);\n  });\n};\n\nvar validateDefinitions = function (documentMetadata, results) {\n  // Validate unused definitions\n  _.each(documentMetadata.definitions, function (metadata, id) {\n    var defPath = JsonRefs.pathFromPtr(id);\n    var defType = defPath[0].substring(0, defPath[0].length - 1);\n    var displayId = documentMetadata.swaggerVersion === '1.2' ? defPath[defPath.length - 1] : id;\n    var code = defType === 'securityDefinition' ? 'SECURITY_DEFINITION' : defType.toUpperCase();\n    var msgPrefix = defType === 'securityDefinition' ?\n                             'Security definition' :\n                             defType.charAt(0).toUpperCase() + defType.substring(1);\n\n    if (metadata.references.length === 0 && !metadata.inline) {\n      // Swagger 1.2 authorization scope\n      if (metadata.scopePath) {\n        code += '_SCOPE';\n        msgPrefix += ' scope';\n        defPath = metadata.scopePath;\n      }\n\n      createUnusedErrorOrWarning(displayId, code, msgPrefix, defPath, results.warnings);\n    }\n  });\n};\n\nvar validateParameters = function (spec, documentMetadata, nPath, parameters, path, results,\n                                   skipMissing) {\n  var createParameterComboError = function (path) {\n    createErrorOrWarning('INVALID_PARAMETER_COMBINATION',\n                         'API cannot have a a body parameter and a ' +\n                           (spec.version === '1.2' ? 'form' : 'formData') + ' parameter',\n                         path, results.errors);\n  };\n  var pathParams = [];\n  var seenBodyParam = false;\n  var seenFormParam = false;\n\n  _.reduce(parameters, function (seenParameters, parameter, index) {\n    var pPath = path.concat(['parameters', index.toString()]);\n\n    // Unresolved parameter\n    if (_.isUndefined(parameter)) {\n      return;\n    }\n\n    // Identify duplicate parameter names\n    validateNoExist(seenParameters, parameter.name, 'PARAMETER', 'Parameter', pPath.concat('name'),\n                    results.errors);\n\n    // Keep track of body and path parameters\n    if (parameter.paramType === 'body' || parameter.in === 'body') {\n      if (seenBodyParam === true) {\n        createErrorOrWarning('DUPLICATE_API_BODY_PARAMETER', 'API has more than one body parameter', pPath,\n                             results.errors);\n      } else if (seenFormParam === true) {\n        createParameterComboError(pPath);\n      }\n\n      seenBodyParam = true;\n    } else if (parameter.paramType === 'form' || parameter.in === 'formData') {\n      if (seenBodyParam === true) {\n        createParameterComboError(pPath);\n      }\n\n      seenFormParam = true;\n    } else if (parameter.paramType === 'path' || parameter.in === 'path') {\n      if (nPath.args.indexOf(parameter.name) === -1) {\n        createErrorOrWarning('UNRESOLVABLE_API_PATH_PARAMETER',\n                             'API path parameter could not be resolved: ' + parameter.name, pPath.concat('name'),\n                             results.errors);\n      }\n\n      pathParams.push(parameter.name);\n    }\n\n    if (spec.primitives.indexOf(parameter.type) === -1 && spec.version === '1.2') {\n      addReference(documentMetadata, '#/models/' + parameter.type, pPath.concat('type'), results);\n    }\n\n    // Validate parameter constraints\n    validateSchemaConstraints(documentMetadata, parameter, pPath, results, parameter.skipErrors);\n\n    return seenParameters.concat(parameter.name);\n  }, []);\n\n  // Validate missing path parameters (in path but not in operation.parameters)\n  if (_.isUndefined(skipMissing) || skipMissing === false) {\n    _.each(_.difference(nPath.args, pathParams), function (unused) {\n      createErrorOrWarning('MISSING_API_PATH_PARAMETER', 'API requires path parameter but it is not defined: ' + unused,\n                           documentMetadata.swaggerVersion === '1.2' ? path.slice(0, 2).concat('path') : path,\n                           results.errors);\n    });\n  }\n};\n\nvar validateSwagger1_2 = function (spec, resourceListing, apiDeclarations, callback) { // jshint ignore:line\n  var adResourcePaths = [];\n  var rlDocumentMetadata = getDocumentCache(resourceListing);\n  var rlResourcePaths = [];\n  var results = {\n    errors: [],\n    warnings: [],\n    apiDeclarations: []\n  };\n\n  // Process Resource Listing resource definitions\n  rlResourcePaths = _.reduce(resourceListing.apis, function (seenPaths, api, index) {\n    // Identify duplicate resource paths defined in the Resource Listing\n    validateNoExist(seenPaths, api.path, 'RESOURCE_PATH', 'Resource path', ['apis', index.toString(), 'path'],\n                    results.errors);\n\n    seenPaths.push(api.path);\n\n    return seenPaths;\n  }, []);\n\n  // Process Resource Listing definitions (authorizations)\n  processDocument(rlDocumentMetadata, results);\n\n\n  // Process each API Declaration\n  adResourcePaths = _.reduce(apiDeclarations, function (seenResourcePaths, apiDeclaration, index) {\n    var aResults = results.apiDeclarations[index] = {\n      errors: [],\n      warnings: []\n    };\n    var adDocumentMetadata = getDocumentCache(apiDeclaration);\n\n    // Identify duplicate resource paths defined in the API Declarations\n    validateNoExist(seenResourcePaths, apiDeclaration.resourcePath, 'RESOURCE_PATH', 'Resource path',\n                    ['resourcePath'], aResults.errors);\n\n    if (adResourcePaths.indexOf(apiDeclaration.resourcePath) === -1) {\n      // Identify unused resource paths defined in the API Declarations\n      validateExist(rlResourcePaths, apiDeclaration.resourcePath, 'RESOURCE_PATH', 'Resource path',\n                    ['resourcePath'], aResults.errors);\n\n      seenResourcePaths.push(apiDeclaration.resourcePath);\n    }\n\n    // TODO: Process authorization references\n    // Not possible due to https://github.com/swagger-api/swagger-spec/issues/159\n\n    // Process models\n    processDocument(adDocumentMetadata, aResults);\n\n    // Process the API definitions\n    _.reduce(apiDeclaration.apis, function (seenPaths, api, index) {\n      var aPath = ['apis', index.toString()];\n      var nPath = normalizePath(api.path);\n\n      // Validate duplicate resource path\n      if (seenPaths.indexOf(nPath.path) > -1) {\n        createErrorOrWarning('DUPLICATE_API_PATH', 'API path (or equivalent) already defined: ' + api.path,\n                             aPath.concat('path'), aResults.errors);\n      } else {\n        seenPaths.push(nPath.path);\n      }\n\n      // Process the API operations\n      _.reduce(api.operations, function (seenMethods, operation, index) {\n        var oPath = aPath.concat(['operations', index.toString()]);\n\n        // Validate duplicate operation method\n        validateNoExist(seenMethods, operation.method, 'OPERATION_METHOD', 'Operation method', oPath.concat('method'),\n                        aResults.errors);\n\n        // Keep track of the seen methods\n        seenMethods.push(operation.method);\n\n        // Keep track of operation types\n        if (spec.primitives.indexOf(operation.type) === -1 && spec.version === '1.2') {\n          addReference(adDocumentMetadata, '#/models/' + operation.type, oPath.concat('type'), aResults);\n        }\n\n        // Process authorization references\n        processAuthRefs(rlDocumentMetadata, operation.authorizations, oPath.concat('authorizations'), aResults);\n\n        // Validate validate inline constraints\n        validateSchemaConstraints(adDocumentMetadata, operation, oPath, aResults);\n\n        // Validate parameters\n        validateParameters(spec, adDocumentMetadata, nPath, operation.parameters, oPath, aResults);\n\n        // Validate unique response code\n        _.reduce(operation.responseMessages, function (seenResponseCodes, responseMessage, index) {\n          var rmPath = oPath.concat(['responseMessages', index.toString()]);\n\n          validateNoExist(seenResponseCodes, responseMessage.code, 'RESPONSE_MESSAGE_CODE', 'Response message code',\n                          rmPath.concat(['code']), aResults.errors);\n\n          // Validate missing model\n          if (responseMessage.responseModel) {\n            addReference(adDocumentMetadata, '#/models/' + responseMessage.responseModel,\n                         rmPath.concat('responseModel'), aResults);\n          }\n\n          return seenResponseCodes.concat(responseMessage.code);\n        }, []);\n\n        return seenMethods;\n      }, []);\n\n      return seenPaths;\n    }, []);\n\n    // Validate API Declaration definitions\n    validateDefinitions(adDocumentMetadata, aResults);\n\n    return seenResourcePaths;\n  }, []);\n\n  // Validate API Declaration definitions\n  validateDefinitions(rlDocumentMetadata, results);\n\n  // Identify unused resource paths defined in the Resource Listing\n  _.each(_.difference(rlResourcePaths, adResourcePaths), function (unused) {\n    var index = rlResourcePaths.indexOf(unused);\n\n    createUnusedErrorOrWarning(resourceListing.apis[index].path, 'RESOURCE_PATH', 'Resource path',\n                               ['apis', index.toString(), 'path'], results.errors);\n  });\n\n  callback(undefined, results);\n};\n\nvar validateSwagger2_0 = function (spec, swaggerObject, callback) { // jshint ignore:line\n  var documentMetadata = getDocumentCache(swaggerObject);\n  var results = {\n    errors: [],\n    warnings: []\n  };\n\n  // Process definitions\n  processDocument(documentMetadata, results);\n\n  // Process security references\n  processAuthRefs(documentMetadata, swaggerObject.security, ['security'], results);\n\n  _.reduce(documentMetadata.resolved.paths, function (seenPaths, path, name) {\n    var pPath = ['paths', name];\n    var nPath = normalizePath(name);\n\n    // Validate duplicate resource path\n    if (seenPaths.indexOf(nPath.path) > -1) {\n      createErrorOrWarning('DUPLICATE_API_PATH', 'API path (or equivalent) already defined: ' + name, pPath,\n                           results.errors);\n    }\n\n    // Validate parameters\n    validateParameters(spec, documentMetadata, nPath, path.parameters, pPath, results, true);\n\n    // Validate the Operations\n    _.each(path, function (operation, method) {\n      var cParams = [];\n      var oPath = pPath.concat(method);\n      var seenParams = [];\n\n      if (validOptionNames.indexOf(method) === -1) {\n        return;\n      }\n\n      // Process security references\n      processAuthRefs(documentMetadata, operation.security, oPath.concat('security'), results);\n\n      // Compose parameters from path global parameters and operation parameters\n      _.each(operation.parameters, function (parameter) {\n        // Can happen with invalid references\n        if (_.isUndefined(parameter)) {\n          return;\n        }\n\n        cParams.push(parameter);\n\n        seenParams.push(parameter.name + ':' + parameter.in);\n      });\n\n      _.each(path.parameters, function (parameter) {\n        var cloned = _.cloneDeep(parameter);\n\n        // The only errors that can occur here are schema constraint validation errors which are already reported above\n        // so do not report them again.\n        cloned.skipErrors = true;\n\n        if (seenParams.indexOf(parameter.name + ':' + parameter.in) === -1) {\n          cParams.push(cloned);\n        }\n      });\n\n      // Validate parameters\n      validateParameters(spec, documentMetadata, nPath, cParams, oPath, results);\n\n      // Validate responses\n      _.each(operation.responses, function (response, responseCode) {\n        // Do not process references to missing responses\n        if (!_.isUndefined(response)) {\n          // Validate validate inline constraints\n          validateSchemaConstraints(documentMetadata, response, oPath.concat('responses', responseCode), results);\n        }\n      });\n    });\n\n    return seenPaths.concat(nPath.path);\n  }, []);\n\n  // Validate definitions\n  validateDefinitions(documentMetadata, results);\n\n  callback(undefined, results);\n};\n\nvar validateSemantically = function (spec, rlOrSO, apiDeclarations, callback) {\n  var cbWrapper = function (err, results) {\n    callback(err, helpers.formatResults(results));\n  };\n  if (spec.version === '1.2') {\n    validateSwagger1_2(spec, rlOrSO, apiDeclarations, cbWrapper); // jshint ignore:line\n  } else {\n    validateSwagger2_0(spec, rlOrSO, cbWrapper); // jshint ignore:line\n  }\n};\n\nvar validateStructurally = function (spec, rlOrSO, apiDeclarations, callback) {\n  validateAgainstSchema(spec, spec.version === '1.2' ? 'resourceListing.json' : 'schema.json', rlOrSO,\n                        function (err, results) {\n                          if (err) {\n                            return callback(err);\n                          }\n\n                          // Only validate the API Declarations if the API is 1.2 and the Resource Listing was valid\n                          if (!results && spec.version === '1.2') {\n                            results = {\n                              errors: [],\n                              warnings: [],\n                              apiDeclarations: []\n                            };\n\n                            async.map(apiDeclarations, function (apiDeclaration, callback2) {\n                              validateAgainstSchema(spec, 'apiDeclaration.json', apiDeclaration, callback2);\n                            }, function (err, allResults) {\n                              if (err) {\n                                return callback(err);\n                              }\n\n                              _.each(allResults, function (result, index) {\n                                results.apiDeclarations[index] = result;\n                              });\n\n                              callback(undefined, results);\n                            });\n                          } else {\n                            callback(undefined, results);\n                          }\n                        });\n};\n\n/**\n * Creates a new Swagger specification object.\n *\n * @param {string} version - The Swagger version\n *\n * @constructor\n */\nvar Specification = function (version) {\n  var that = this;\n  var createValidators = function (spec, validatorsMap) {\n    return _.reduce(validatorsMap, function (result, schemas, schemaName) {\n      result[schemaName] = helpers.createJsonValidator(schemas);\n\n      return result;\n    }, {});\n  };\n  var fixSchemaId = function (schemaName) {\n    // Swagger 1.2 schema files use one id but use a different id when referencing schema files.  We also use the schema\n    // file name to reference the schema in ZSchema.  To fix this so that the JSON Schema validator works properly, we\n    // need to set the id to be the name of the schema file.\n    var fixed = _.cloneDeep(that.schemas[schemaName]);\n\n    fixed.id = schemaName;\n\n    return fixed;\n  };\n  var primitives = ['string', 'number', 'boolean', 'integer', 'array'];\n\n  switch (version) {\n  case '1.2':\n    this.docsUrl = 'https://github.com/swagger-api/swagger-spec/blob/master/versions/1.2.md';\n    this.primitives = _.union(primitives, ['void', 'File']);\n    this.schemasUrl = 'https://github.com/swagger-api/swagger-spec/tree/master/schemas/v1.2';\n\n    // Here explicitly to allow browserify to work\n    this.schemas = {\n      'apiDeclaration.json': require('../schemas/1.2/apiDeclaration.json'),\n      'authorizationObject.json': require('../schemas/1.2/authorizationObject.json'),\n      'dataType.json': require('../schemas/1.2/dataType.json'),\n      'dataTypeBase.json': require('../schemas/1.2/dataTypeBase.json'),\n      'infoObject.json': require('../schemas/1.2/infoObject.json'),\n      'modelsObject.json': require('../schemas/1.2/modelsObject.json'),\n      'oauth2GrantType.json': require('../schemas/1.2/oauth2GrantType.json'),\n      'operationObject.json': require('../schemas/1.2/operationObject.json'),\n      'parameterObject.json': require('../schemas/1.2/parameterObject.json'),\n      'resourceListing.json': require('../schemas/1.2/resourceListing.json'),\n      'resourceObject.json': require('../schemas/1.2/resourceObject.json')\n    };\n\n    this.validators = createValidators(this, {\n      'apiDeclaration.json': _.map([\n        'dataTypeBase.json',\n        'modelsObject.json',\n        'oauth2GrantType.json',\n        'authorizationObject.json',\n        'parameterObject.json',\n        'operationObject.json',\n        'apiDeclaration.json'\n      ], fixSchemaId),\n      'resourceListing.json': _.map([\n        'resourceObject.json',\n        'infoObject.json',\n        'oauth2GrantType.json',\n        'authorizationObject.json',\n        'resourceListing.json'\n      ], fixSchemaId)\n    });\n\n    break;\n\n  case '2.0':\n    this.docsUrl = 'https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md';\n    this.primitives = _.union(primitives, ['file']);\n    this.schemasUrl = 'https://github.com/swagger-api/swagger-spec/tree/master/schemas/v2.0';\n\n    // Here explicitly to allow browserify to work\n    this.schemas = {\n      'schema.json': require('../schemas/2.0/schema.json')\n    };\n\n    this.validators = createValidators(this, {\n      'schema.json': [fixSchemaId('schema.json')]\n    });\n\n    break;\n\n  default:\n    throw new Error(version + ' is an unsupported Swagger specification version');\n  }\n\n  this.version = version;\n};\n\n/**\n * Returns the result of the validation of the Swagger document(s).\n *\n * @param {object} rlOrSO - The Swagger Resource Listing (1.2) or Swagger Object (2.0)\n * @param {object[]} [apiDeclarations] - The array of Swagger API Declarations (1.2)\n * @param {resultCallback} callback - The result callback\n *\n * @returns undefined if validation passes or an object containing errors and/or warnings\n * @throws Error if the arguments provided are not valid\n */\nSpecification.prototype.validate = function (rlOrSO, apiDeclarations, callback) {\n  // Validate arguments\n  switch (this.version) {\n  case '1.2':\n    // Validate arguments\n    if (_.isUndefined(rlOrSO)) {\n      throw new Error('resourceListing is required');\n    } else if (!_.isPlainObject(rlOrSO)) {\n      throw new TypeError('resourceListing must be an object');\n    }\n\n    if (_.isUndefined(apiDeclarations)) {\n      throw new Error('apiDeclarations is required');\n    } else if (!_.isArray(apiDeclarations)) {\n      throw new TypeError('apiDeclarations must be an array');\n    }\n\n    break;\n\n  case '2.0':\n    // Validate arguments\n    if (_.isUndefined(rlOrSO)) {\n      throw new Error('swaggerObject is required');\n    } else if (!_.isPlainObject(rlOrSO)) {\n      throw new TypeError('swaggerObject must be an object');\n    }\n\n    break;\n  }\n\n  if (this.version === '2.0') {\n    callback = arguments[1];\n  }\n\n  if (_.isUndefined(callback)) {\n    throw new Error('callback is required');\n  } else if (!_.isFunction(callback)) {\n    throw new TypeError('callback must be a function');\n  }\n\n  // For Swagger 2.0, make sure apiDeclarations is an empty array\n  if (this.version === '2.0') {\n    apiDeclarations = [];\n  }\n\n  var that = this;\n\n  // Perform the validation\n  validateStructurally(this, rlOrSO, apiDeclarations, function (err, result) {\n    if (err || helpers.formatResults(result)) {\n      callback(err, result);\n    } else {\n      validateSemantically(that, rlOrSO, apiDeclarations, callback);\n    }\n  });\n};\n\n/**\n * Returns a JSON Schema representation of a composed model based on its id or reference.\n *\n * Note: For Swagger 1.2, we only perform structural validation prior to composing the model.\n *\n * @param {object} apiDOrSO - The Swagger Resource API Declaration (1.2) or the Swagger Object (2.0)\n * @param {string} modelIdOrRef - The model id (1.2) or the reference to the model (1.2 or 2.0)\n * @param {resultCallback} callback - The result callback\n *\n * @returns the object representing a composed object\n *\n * @throws Error if there are validation errors while creating\n */\nSpecification.prototype.composeModel = function (apiDOrSO, modelIdOrRef, callback) {\n  var swaggerVersion = helpers.getSwaggerVersion(apiDOrSO);\n  var doComposition = function (err, results) {\n    var documentMetadata;\n\n    if (err) {\n      return callback(err);\n    } else if (helpers.getErrorCount(results) > 0) {\n      return handleValidationError(results, callback);\n    }\n\n    documentMetadata = getDocumentCache(apiDOrSO);\n    results = {\n      errors: [],\n      warnings: []\n    };\n\n    processDocument(documentMetadata, results);\n\n    if (!documentMetadata.definitions[modelIdOrRef]) {\n      return callback();\n    }\n\n    if (helpers.getErrorCount(results) > 0) {\n      return handleValidationError(results, callback);\n    }\n\n    callback(undefined, getOrComposeSchema(documentMetadata, modelIdOrRef));\n  };\n\n  switch (this.version) {\n  case '1.2':\n    // Validate arguments\n    if (_.isUndefined(apiDOrSO)) {\n      throw new Error('apiDeclaration is required');\n    } else if (!_.isPlainObject(apiDOrSO)) {\n      throw new TypeError('apiDeclaration must be an object');\n    }\n\n    if (_.isUndefined(modelIdOrRef)) {\n      throw new Error('modelId is required');\n    }\n\n    break;\n\n  case '2.0':\n    // Validate arguments\n    if (_.isUndefined(apiDOrSO)) {\n      throw new Error('swaggerObject is required');\n    } else if (!_.isPlainObject(apiDOrSO)) {\n      throw new TypeError('swaggerObject must be an object');\n    }\n\n    if (_.isUndefined(modelIdOrRef)) {\n      throw new Error('modelRef is required');\n    }\n\n    break;\n  }\n\n  if (_.isUndefined(callback)) {\n    throw new Error('callback is required');\n  } else if (!_.isFunction(callback)) {\n    throw new TypeError('callback must be a function');\n  }\n\n  if (modelIdOrRef.charAt(0) !== '#') {\n    if (this.version === '1.2') {\n      modelIdOrRef = '#/models/' + modelIdOrRef;\n    } else {\n      throw new Error('modelRef must be a JSON Pointer');\n    }\n  }\n\n  // Ensure the document is valid first\n  if (swaggerVersion === '1.2') {\n    validateAgainstSchema(this, 'apiDeclaration.json', apiDOrSO, doComposition);\n  } else {\n    this.validate(apiDOrSO, doComposition);\n  }\n};\n\n/**\n * Validates a model based on its id.\n *\n * Note: For Swagger 1.2, we only perform structural validation prior to composing the model.\n *\n * @param {object} apiDOrSO - The Swagger Resource API Declaration (1.2) or the Swagger Object (2.0)\n * @param {string} modelIdOrRef - The model id (1.2) or the reference to the model (1.2 or 2.0)\n * @param {*} data - The model to validate\n * @param {resultCallback} callback - The result callback\n *\n * @returns undefined if validation passes or an object containing errors and/or warnings\n *\n * @throws Error if there are validation errors while creating\n */\nSpecification.prototype.validateModel = function (apiDOrSO, modelIdOrRef, data, callback) {\n  switch (this.version) {\n  case '1.2':\n    // Validate arguments\n    if (_.isUndefined(apiDOrSO)) {\n      throw new Error('apiDeclaration is required');\n    } else if (!_.isPlainObject(apiDOrSO)) {\n      throw new TypeError('apiDeclaration must be an object');\n    }\n\n    if (_.isUndefined(modelIdOrRef)) {\n      throw new Error('modelId is required');\n    }\n\n    break;\n\n  case '2.0':\n    // Validate arguments\n    if (_.isUndefined(apiDOrSO)) {\n      throw new Error('swaggerObject is required');\n    } else if (!_.isPlainObject(apiDOrSO)) {\n      throw new TypeError('swaggerObject must be an object');\n    }\n\n    if (_.isUndefined(modelIdOrRef)) {\n      throw new Error('modelRef is required');\n    }\n\n    break;\n  }\n\n  if (_.isUndefined(data)) {\n    throw new Error('data is required');\n  }\n\n  if (_.isUndefined(callback)) {\n    throw new Error('callback is required');\n  } else if (!_.isFunction(callback)) {\n    throw new TypeError('callback must be a function');\n  }\n\n  var that = this;\n\n  this.composeModel(apiDOrSO, modelIdOrRef, function (err, result) {\n    if (err) {\n      return callback(err);\n    }\n\n    validateAgainstSchema(that, result, data, callback);\n  });\n};\n\n/**\n * Returns a fully resolved document or document fragment.  (Does not perform validation as this is typically called\n * after validation occurs.))\n *\n * @param {object} document - The document to resolve or the document containing the reference to resolve\n * @param {string} [ptr] - The JSON Pointer or undefined to return the whole document\n * @param {resultCallback} callback - The result callback\n *\n * @returns the fully resolved document or fragment\n *\n * @throws Error if there are upstream errors\n */\nSpecification.prototype.resolve = function (document, ptr, callback) {\n  var documentMetadata;\n  var respond = function (document) {\n    if (_.isString(ptr)) {\n      return callback(undefined, traverse(document).get(JsonRefs.pathFromPtr(ptr)));\n    } else {\n      return callback(undefined, document);\n    }\n  };\n\n  // Validate arguments\n  if (_.isUndefined(document)) {\n    throw new Error('document is required');\n  } else if (!_.isPlainObject(document)) {\n    throw new TypeError('document must be an object');\n  }\n\n  if (arguments.length === 2) {\n    callback = arguments[1];\n    ptr = undefined;\n  }\n\n  if (!_.isUndefined(ptr) && !_.isString(ptr)) {\n    throw new TypeError('ptr must be a JSON Pointer string');\n  }\n\n  if (_.isUndefined(callback)) {\n    throw new Error('callback is required');\n  } else if (!_.isFunction(callback)) {\n    throw new TypeError('callback must be a function');\n  }\n\n  documentMetadata = getDocumentCache(document);\n\n  // Swagger 1.2 is not supported due to invalid JSON References being used.  Even if the JSON References were valid,\n  // the JSON Schema for Swagger 1.2 do not allow JavaScript objects in all places where the resoution would occur.\n  if (documentMetadata.swaggerVersion === '1.2') {\n    throw new Error('Swagger 1.2 is not supported');\n  }\n\n  if (!documentMetadata.resolved) {\n    // Ensure the document is valid first\n    this.validate(document, function (err, results) {\n      if (err) {\n        return callback(err);\n      } else if (helpers.getErrorCount(results) > 0) {\n        return handleValidationError(results, callback);\n      }\n\n      return respond(documentMetadata.resolved);\n    });\n  } else {\n    return respond(documentMetadata.resolved);\n  }\n};\n\n/**\n * Converts the Swagger 1.2 documents to a Swagger 2.0 document.\n *\n * @param {object} resourceListing - The Swagger Resource Listing\n * @param {object[]} [apiDeclarations] - The array of Swagger API Declarations\n * @param {boolean=false} [skipValidation] - Whether or not to skip validation\n * @param {resultCallback} callback - The result callback\n *\n * @returns the converted Swagger document\n *\n * @throws Error if the arguments provided are not valid\n */\nSpecification.prototype.convert = function (resourceListing, apiDeclarations, skipValidation, callback) {\n  var doConvert = function (resourceListing, apiDeclarations) {\n    callback(undefined, swaggerConverter(resourceListing, apiDeclarations));\n  };\n\n  if (this.version !== '1.2') {\n    throw new Error('Specification#convert only works for Swagger 1.2');\n  }\n\n  // Validate arguments\n  if (_.isUndefined(resourceListing)) {\n    throw new Error('resourceListing is required');\n  } else if (!_.isPlainObject(resourceListing)) {\n    throw new TypeError('resourceListing must be an object');\n  }\n\n  // API Declarations are optional because swagger-converter was written to support it\n  if (_.isUndefined(apiDeclarations)) {\n    apiDeclarations = [];\n  }\n\n  if (!_.isArray(apiDeclarations)) {\n    throw new TypeError('apiDeclarations must be an array');\n  }\n\n  if (arguments.length < 4) {\n    callback = arguments[arguments.length - 1];\n  }\n\n  if (_.isUndefined(callback)) {\n    throw new Error('callback is required');\n  } else if (!_.isFunction(callback)) {\n    throw new TypeError('callback must be a function');\n  }\n\n  if (skipValidation === true) {\n    doConvert(resourceListing, apiDeclarations);\n  } else {\n    this.validate(resourceListing, apiDeclarations, function (err, results) {\n      if (err) {\n        return callback(err);\n      } else if (helpers.getErrorCount(results) > 0) {\n        return handleValidationError(results, callback);\n      }\n\n      doConvert(resourceListing, apiDeclarations);\n    });\n  }\n};\n\nmodule.exports.v1 = module.exports.v1_2 = new Specification('1.2'); // jshint ignore:line\nmodule.exports.v2 = module.exports.v2_0 = new Specification('2.0'); // jshint ignore:line\n","/home/travis/build/npmtest/node-npmtest-swagger/node_modules/swagger-tools/node_modules/swagger-converter/index.js":"/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014 Apigee Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\nvar urlParse = require('url').parse;\nvar clone = require('lodash.clonedeep');\n\nvar primitiveTypes = [\n  'string',\n  'number',\n  'boolean',\n  'integer',\n  'array',\n  'void',\n  'File'\n];\n\nif (typeof window === 'undefined') {\n  module.exports = convert;\n} else {\n  window.SwaggerConverter = window.SwaggerConverter || {\n    convert: convert\n  };\n}\n\n/*\n * Converts Swagger 1.2 specs file to Swagger 2.0 specs.\n * @param resourceListing {object} - root Swagger 1.2 document where it has a\n *  list of all paths\n * @param apiDeclarations {array} - a list of all resources listed in\n * resourceListing. Array of objects\n * @returns {object} - Fully converted Swagger 2.0 document\n*/\nfunction convert(resourceListing, apiDeclarations) {\n  if (typeof resourceListing !== 'object') {\n    throw new Error('resourceListing must be an object');\n  }\n  if (!Array.isArray(apiDeclarations)) {\n    apiDeclarations = [];\n  }\n\n  var convertedSecurityNames = {};\n  var models = {};\n  var result = {\n    swagger: '2.0',\n    info: buildInfo(resourceListing),\n    paths: {}\n  };\n\n  if (resourceListing.authorizations) {\n    result.securityDefinitions = buildSecurityDefinitions(resourceListing,\n      convertedSecurityNames);\n  }\n\n  if (resourceListing.basePath) {\n    assignPathComponents(resourceListing.basePath, result);\n  }\n\n  extend(models, resourceListing.models);\n\n  // Handle embedded documents\n  if (Array.isArray(resourceListing.apis)) {\n    if (apiDeclarations.length > 0) {\n      result.tags = [];\n    }\n    resourceListing.apis.forEach(function(api) {\n      if (result.tags) {\n        result.tags.push({\n          'name': api.path.replace('.{format}', '').substring(1),\n          'description': api.description});\n      }\n      if (Array.isArray(api.operations)) {\n        result.paths[api.path] = buildPath(api, resourceListing);\n      }\n    });\n  }\n\n  apiDeclarations.forEach(function(apiDeclaration) {\n\n    // For each apiDeclaration if there is a basePath, assign path components\n    // This might override previous assignments\n    if (apiDeclaration.basePath) {\n      assignPathComponents(apiDeclaration.basePath, result);\n    }\n\n    if (!Array.isArray(apiDeclaration.apis)) { return; }\n    apiDeclaration.apis.forEach(function(api) {\n      result.paths[api.path] = buildPath(api, apiDeclaration);\n\n    });\n    if (apiDeclaration.models && Object.keys(apiDeclaration.models).length) {\n      extend(models, transformAllModels(apiDeclaration.models));\n    }\n  });\n\n  if (Object.keys(models).length) {\n    result.definitions = transformAllModels(models);\n  }\n\n  return result;\n}\n\n/*\n * Builds \"info\" section of Swagger 2.0 document\n * @param source {object} - Swagger 1.2 document object\n * @returns {object} - \"info\" section of Swagger 2.0 document\n*/\nfunction buildInfo(source) {\n  var info = {\n    version: source.apiVersion,\n    title: 'Title was not specified'\n  };\n\n  if (typeof source.info === 'object') {\n\n    if (source.info.title) {\n      info.title = source.info.title;\n    }\n\n    if (source.info.description) {\n      info.description = source.info.description;\n    }\n\n    if (source.info.contact) {\n      info.contact = {\n        email: source.info.contact\n      };\n    }\n\n    if (source.info.license) {\n      info.license = {\n        name: source.info.license,\n        url: source.info.licenseUrl\n      };\n    }\n\n    if (source.info.termsOfServiceUrl) {\n      info.termsOfService = source.info.termsOfServiceUrl;\n    }\n  }\n\n  return info;\n}\n\n/*\n * Assigns host, basePath and schemes for Swagger 2.0 result document from\n * Swagger 1.2 basePath.\n * @param basePath {string} - the base path from Swagger 1.2\n * @param result {object} - Swagger 2.0 document\n*/\nfunction assignPathComponents(basePath, result) {\n  var url = urlParse(basePath);\n  result.host = url.host;\n  result.basePath = url.path;\n  if (url.protocol) {\n    result.schemes = [url.protocol.substr(0, url.protocol.length - 1)];\n  }\n}\n\n/*\n * Process a data type object.\n *\n * @see {@link https://github.com/swagger-api/swagger-spec/blob/master/versions/\n *  1.2.md#433-data-type-fields}\n *\n * @param field {object} - A data type field\n *\n * @returns {object} - Swagger 2.0 equivalent\n */\nfunction processDataType(field, fixRef) {\n  field = clone(field);\n\n  // Checking for the existence of '#/definitions/' is related to this bug:\n  //   https://github.com/apigee-127/swagger-converter/issues/6\n  if (field.$ref && field.$ref.indexOf('#/definitions/') === -1) {\n    field.$ref = '#/definitions/' + field.$ref;\n  } else if (field.items && field.items.$ref &&\n             field.items.$ref.indexOf('#/definitions/') === -1) {\n    field.items.$ref = '#/definitions/' + field.items.$ref;\n  }\n\n  if (fixRef) {\n    if (field.type && primitiveTypes.indexOf(field.type) === -1) {\n      field = {$ref: '#/definitions/' + field.type};\n    }\n  }\n\n  if (field.minimum) {\n    field.minimum = fixNonStringValue(field.minimum);\n  }\n\n  if (field.maximum) {\n    field.maximum = fixNonStringValue(field.maximum);\n  }\n\n  if (field.defaultValue) {\n    field.default = field.defaultValue;\n    delete field.defaultValue;\n    if (field.type && field.type !== 'string') {\n      field.default = fixNonStringValue(field.default);\n    }\n  }\n\n  return field;\n}\n\n/*\n * Builds a Swagger 2.0 path object form a Swagger 1.2 path object\n * @param api {object} - Swagger 1.2 path object\n * @param apiDeclaration {object} - parent apiDeclaration\n * @returns {object} - Swagger 2.0 path object\n*/\nfunction buildPath(api, apiDeclaration) {\n  var path = {};\n\n  api.operations.forEach(function(oldOperation) {\n    var method = oldOperation.method.toLowerCase();\n    path[method] = buildOperation(oldOperation, apiDeclaration.produces,\n      apiDeclaration.consumes, apiDeclaration.resourcePath);\n  });\n\n  return path;\n}\n\n/*\n * Builds a Swagger 2.0 operation object form a Swagger 1.2 operation object\n * @param oldOperation {object} - Swagger 1.2 operation object\n * @param produces {array} - from containing apiDeclaration\n * @param consumes {array} - from containing apiDeclaration\n * @returns {object} - Swagger 2.0 operation object\n*/\nfunction buildOperation(oldOperation, produces, consumes, resourcePath) {\n  var operation = {\n    responses: {},\n    description: oldOperation.description || ''\n  };\n\n  if (resourcePath) {\n    operation.tags = [];\n    operation.tags.push(resourcePath.substr(1));\n  }\n\n  if (oldOperation.summary) {\n    operation.summary = oldOperation.summary;\n  }\n\n  if (oldOperation.nickname) {\n    operation.operationId = oldOperation.nickname;\n  }\n\n  if (produces) { operation.produces = produces; }\n  if (consumes) { operation.consumes = consumes; }\n\n  if (Array.isArray(oldOperation.parameters) &&\n      oldOperation.parameters.length) {\n    operation.parameters = oldOperation.parameters.map(function(parameter) {\n      return buildParameter(parameter);\n    });\n  }\n\n  if (Array.isArray(oldOperation.responseMessages)) {\n    oldOperation.responseMessages.forEach(function(oldResponse) {\n      operation.responses[oldResponse.code] = buildResponse(oldResponse);\n    });\n  }\n\n  if (!Object.keys(operation.responses).length ||\n    (!operation.responses[200] && oldOperation.type)) {\n    operation.responses[200] = {\n      description: 'No response was specified'\n    };\n  }\n\n  if (oldOperation.type && oldOperation.type !== 'void') {\n    var schema = buildParamType(oldOperation);\n    if (primitiveTypes.indexOf(oldOperation.type) === -1) {\n      schema = {\n        '$ref': '#/definitions/' + oldOperation.type\n      };\n    }\n    operation.responses['200'].schema = schema;\n  }\n\n  return operation;\n}\n\n/*\n * Builds a Swagger 2.0 response object form a Swagger 1.2 response object\n * @param oldResponse {object} - Swagger 1.2 response object\n * @returns {object} - Swagger 2.0 response object\n*/\nfunction buildResponse(oldResponse) {\n  var response = {};\n\n  // TODO: Confirm this is correct\n  response.description = oldResponse.message;\n\n  return response;\n}\n\n/*\n * Converts Swagger 1.2 parameter object to Swagger 2.0 parameter object\n * @param oldParameter {object} - Swagger 1.2 parameter object\n * @returns {object} - Swagger 2.0 parameter object\n*/\nfunction buildParameter(oldParameter) {\n  var parameter = {\n    in: oldParameter.paramType,\n    description: oldParameter.description,\n    name: oldParameter.name,\n    required: !!oldParameter.required\n  };\n\n  if (primitiveTypes.indexOf(oldParameter.type) === -1) {\n    parameter.schema = {$ref: '#/definitions/' + oldParameter.type};\n  } else if (oldParameter.paramType === 'body') {\n    parameter.schema = buildParamType(oldParameter);\n  } else {\n    extend(parameter, buildParamType(oldParameter));\n  }\n\n  // form was changed to formData in Swagger 2.0\n  if (parameter.in === 'form') {\n    parameter.in = 'formData';\n  }\n\n  return parameter;\n}\n\n/*\n * Converts Swagger 1.2 type fields from parameter object into their Swagger 2.0 conterparts\n * @param oldParameter {object} - Swagger 1.2 parameter object\n * @returns {object} - Swagger 2.0 type fields from parameter object\n*/\nfunction buildParamType(oldParameter) {\n  var paramType = {};\n  var copyProperties = [\n    'default',\n    'maximum',\n    'minimum',\n    'items'\n  ];\n\n  oldParameter = processDataType(oldParameter, false);\n\n  paramType.type = oldParameter.type.toLowerCase();\n\n  copyProperties.forEach(function(name) {\n    if (typeof oldParameter[name] !== 'undefined') {\n      paramType[name] = oldParameter[name];\n    }\n  });\n\n  if (typeof oldParameter.defaultValue !== 'undefined') {\n    paramType.default = oldParameter.defaultValue;\n  }\n\n  return paramType;\n}\n\n/*\n * Convertes Swagger 1.2 authorization definitions to Swagger 2.0 security\n *   definitions\n *\n * @param resourceListing {object} - The Swagger 1.2 Resource Listing document\n * @param convertedSecurityNames {object} - A list of original Swagger 1.2\n * authorization names and the new Swagger 2.0\n *  security names associated with it (This is required because Swagger 2.0 only\n *  supports one oauth2 flow per security definition but in Swagger 1.2 you\n *  could describe two (implicit and authorization_code).  To support this, we\n *  will create a per-flow version of each oauth2 definition, where necessary,\n *  and keep track of the new names so that when we handle security references\n *  we reference things properly.)\n *\n * @returns {object} - Swagger 2.0 security definitions\n */\nfunction buildSecurityDefinitions(resourceListing, convertedSecurityNames) {\n  var securityDefinitions = {};\n\n  Object.keys(resourceListing.authorizations).forEach(function(name) {\n    var authorization = resourceListing.authorizations[name];\n    var createDefinition = function createDefinition(oName) {\n      var securityDefinition = securityDefinitions[oName || name] = {\n        type: authorization.type\n      };\n\n      if (authorization.passAs) {\n        securityDefinition.in = authorization.passAs;\n      }\n\n      if (authorization.keyname) {\n        securityDefinition.name = authorization.keyname;\n      }\n\n      return securityDefinition;\n    };\n\n    // For oauth2 types, 1.2 describes multiple \"flows\" in one auth and for 2.0,\n    // that is not an option so we need to\n    // create one security definition per flow and keep track of this mapping.\n    if (authorization.grantTypes) {\n      convertedSecurityNames[name] = [];\n\n      Object.keys(authorization.grantTypes).forEach(function(gtName) {\n        var grantType = authorization.grantTypes[gtName];\n        var oName = name + '_' + gtName;\n        var securityDefinition = createDefinition(oName);\n\n        convertedSecurityNames[name].push(oName);\n\n        if (gtName === 'implicit') {\n          securityDefinition.flow = 'implicit';\n        } else {\n          securityDefinition.flow = 'accessCode';\n        }\n\n        switch (gtName) {\n        case 'implicit':\n          securityDefinition.authorizationUrl = grantType.loginEndpoint.url;\n          break;\n\n        case 'authorization_code':\n          securityDefinition.authorizationUrl =\n            grantType.tokenRequestEndpoint.url;\n          securityDefinition.tokenUrl = grantType.tokenEndpoint.url;\n          break;\n        }\n\n        if (authorization.scopes) {\n          securityDefinition.scopes = {};\n\n          authorization.scopes.forEach(function(scope) {\n            securityDefinition.scopes[scope.scope] = scope.description ||\n              ('Undescribed ' + scope.scope);\n          });\n        }\n      });\n    } else {\n      createDefinition();\n    }\n  });\n\n  return securityDefinitions;\n}\n\n/*\n * Transforms a Swagger 1.2 model object to a Swagger 2.0 model object\n * @param model {object} - (mutable) Swagger 1.2 model object\n*/\nfunction transformModel(model) {\n  if (typeof model.properties === 'object') {\n    Object.keys(model.properties).forEach(function(propertieName) {\n      model.properties[propertieName] =\n        processDataType(model.properties[propertieName], true);\n    });\n  }\n}\n\n/*\n * Transfers the \"models\" object of Swagger 1.2 specs to Swagger 2.0 definitions\n * object\n * @param models {object} - (mutable) an object containing Swagger 1.2 objects\n * @returns {object} - transformed modles object\n*/\nfunction transformAllModels(models) {\n  var modelsClone = clone(models);\n\n  if (typeof models !== 'object') {\n    throw new Error('models must be object');\n  }\n\n  var hierarchy = {};\n\n  Object.keys(modelsClone).forEach(function(modelId) {\n    var model = modelsClone[modelId];\n    delete model['id'];\n\n    transformModel(model);\n\n    if (model.subTypes) {\n      hierarchy[modelId] = model.subTypes;\n\n      delete model.subTypes;\n    }\n  });\n\n  Object.keys(hierarchy).forEach(function(parent) {\n    hierarchy[parent].forEach(function(childId) {\n      var childModel = modelsClone[childId];\n\n      if (childModel) {\n        var allOf = (childModel.allOf || []).concat({\n          $ref: '#/definitions/' + parent\n        }).concat(clone(childModel));\n        for (var member in childModel) {\n          delete childModel[member];\n        }\n        childModel.allOf = allOf;\n      }\n    });\n  });\n\n  return modelsClone;\n}\n\n/*\n * Extends an object with another\n * @param source {object} - object that will get extended\n * @parma destination {object} - object the will used to extend source\n*/\nfunction extend(source, destination) {\n  if (typeof source !== 'object') {\n    throw new Error('source must be objects');\n  }\n\n  if (typeof destination === 'object') {\n    Object.keys(destination).forEach(function(key) {\n      source[key] = destination[key];\n    });\n  }\n}\n\n/*\n * Convert string values into the proper type.\n * @param value {*} - value to convert\n * @returns {*} - transformed modles object\n*/\nfunction fixNonStringValue(value) {\n  if (typeof value !== 'string') {\n    return value;\n  }\n\n  try {\n    return JSON.parse(value);\n  } catch (e) {\n    throw Error('incorect property value: ' + e.message);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-swagger/node_modules/swagger-tools/lib/validators.js":"/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014 Apigee Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n'use strict';\n\n// Done this way to make the Browserify build smaller\nvar _ = {\n  cloneDeep: require('lodash-compat/lang/cloneDeep'),\n  each: require('lodash-compat/collection/each'),\n  isArray: require('lodash-compat/lang/isArray'),\n  isBoolean: require('lodash-compat/lang/isBoolean'),\n  isDate: require('lodash-compat/lang/isDate'),\n  isFinite: require('lodash-compat/lang/isFinite'),\n  isNull: require('lodash-compat/lang/isNull'),\n  isNumber: require('lodash-compat/lang/isNumber'),\n  isPlainObject: require('lodash-compat/lang/isPlainObject'),\n  isString: require('lodash-compat/lang/isString'),\n  isUndefined: require('lodash-compat/lang/isUndefined'),\n  map: require('lodash-compat/collection/map'),\n  union: require('lodash-compat/array/union'),\n  uniq: require('lodash-compat/array/uniq')\n};\nvar helpers = require('./helpers');\n\n// http://tools.ietf.org/html/rfc3339#section-5.6\nvar dateRegExp = /^([0-9]{4})-([0-9]{2})-([0-9]{2})$/;\n// http://tools.ietf.org/html/rfc3339#section-5.6\nvar dateTimeRegExp = /^([0-9]{2}):([0-9]{2}):([0-9]{2})(.[0-9]+)?(z|([+-][0-9]{2}:[0-9]{2}))$/;\nvar isValidDate = function (date) {\n  var day;\n  var matches;\n  var month;\n\n  if (_.isDate(date)) {\n    return true;\n  }\n\n  if (!_.isString(date)) {\n    date = date.toString();\n  }\n\n  matches = dateRegExp.exec(date);\n\n  if (matches === null) {\n    return false;\n  }\n\n  day = matches[3];\n  month = matches[2];\n\n  if (month < '01' || month > '12' || day < '01' || day > '31') {\n    return false;\n  }\n\n  return true;\n};\nvar isValidDateTime = function (dateTime) {\n  var hour;\n  var date;\n  var time;\n  var matches;\n  var minute;\n  var parts;\n  var second;\n\n  if (_.isDate(dateTime)) {\n    return true;\n  }\n\n  if (!_.isString(dateTime)) {\n    dateTime = dateTime.toString();\n  }\n\n  parts = dateTime.toLowerCase().split('t');\n  date = parts[0];\n  time = parts.length > 1 ? parts[1] : undefined;\n\n  if (!isValidDate(date)) {\n    return false;\n  }\n\n  matches = dateTimeRegExp.exec(time);\n\n  if (matches === null) {\n    return false;\n  }\n\n  hour = matches[1];\n  minute = matches[2];\n  second = matches[3];\n\n  if (hour > '23' || minute > '59' || second > '59') {\n    return false;\n  }\n\n  return true;\n};\n\nvar throwErrorWithCode = function (code, msg) {\n  var err = new Error(msg);\n\n  err.code = code;\n  err.failedValidation = true;\n\n  throw err;\n};\n\nmodule.exports.validateAgainstSchema = function (schemaOrName, data, validator) {\n  var sanitizeError = function (obj) {\n    // Make anyOf/oneOf errors more human readable (Issue 200)\n    var defType = ['additionalProperties', 'items'].indexOf(obj.path[obj.path.length - 1]) > -1 ?\n          'schema' :\n          obj.path[obj.path.length - 2];\n\n    if (['ANY_OF_MISSING', 'ONE_OF_MISSING'].indexOf(obj.code) > -1) {\n      switch (defType) {\n      case 'parameters':\n        defType = 'parameter';\n        break;\n\n      case 'responses':\n        defType = 'response';\n        break;\n\n      case 'schema':\n        defType += ' ' + obj.path[obj.path.length - 1];\n\n        // no default\n      }\n\n      obj.message = 'Not a valid ' + defType + ' definition';\n    }\n\n    // Remove the params portion of the error\n    delete obj.params;\n    delete obj.schemaId;\n\n    if (obj.inner) {\n      _.each(obj.inner, function (nObj) {\n        sanitizeError(nObj);\n      });\n    }\n  };\n  var schema = _.isPlainObject(schemaOrName) ? _.cloneDeep(schemaOrName) : schemaOrName;\n\n  // We don't check this due to internal usage but if validator is not provided, schemaOrName must be a schema\n  if (_.isUndefined(validator)) {\n    validator = helpers.createJsonValidator([schema]);\n  }\n\n  var valid = validator.validate(data, schema);\n\n  if (!valid) {\n    try {\n      throwErrorWithCode('SCHEMA_VALIDATION_FAILED', 'Failed schema validation');\n    } catch (err) {\n      err.results = {\n        errors: _.map(validator.getLastErrors(), function (err) {\n          sanitizeError(err);\n\n          return err;\n        }),\n        warnings: []\n      };\n\n      throw err;\n    }\n  }\n};\n\n\n/**\n * Validates a schema of type array is properly formed (when necessar).\n *\n * *param {object} schema - The schema object to validate\n *\n * @throws Error if the schema says it's an array but it is not formed properly\n *\n * @see {@link https://github.com/swagger-api/swagger-spec/issues/174}\n */\nvar validateArrayType = module.exports.validateArrayType = function (schema) {\n  // We have to do this manually for now\n  if (schema.type === 'array' && _.isUndefined(schema.items)) {\n    throwErrorWithCode('OBJECT_MISSING_REQUIRED_PROPERTY', 'Missing required property: items');\n  }\n};\n\n/**\n * Validates the request or response content type (when necessary).\n *\n * @param {string[]} gPOrC - The valid consumes at the API scope\n * @param {string[]} oPOrC - The valid consumes at the operation scope\n * @param {object} reqOrRes - The request or response\n *\n * @throws Error if the content type is invalid\n */\nmodule.exports.validateContentType = function (gPOrC, oPOrC, reqOrRes) {\n  // http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.2.1\n  var isResponse = typeof reqOrRes.end === 'function';\n  var contentType = isResponse ? reqOrRes.getHeader('content-type') : reqOrRes.headers['content-type'];\n  var pOrC = _.map(_.union(gPOrC, oPOrC), function (contentType) {\n    return contentType.split(';')[0];\n  });\n\n  if (!contentType) {\n    if (isResponse) {\n      contentType = 'text/plain';\n    } else {\n      contentType = 'application/octet-stream';\n    }\n  }\n\n  contentType = contentType.split(';')[0];\n\n  if (pOrC.length > 0 && (isResponse ?\n                          true :\n                          ['POST', 'PUT'].indexOf(reqOrRes.method) !== -1) && pOrC.indexOf(contentType) === -1) {\n    throw new Error('Invalid content type (' + contentType + ').  These are valid: ' + pOrC.join(', '));\n  }\n};\n\n/**\n * Validates the value against the allowable values (when necessary).\n *\n * @param {*} val - The parameter value\n * @param {string[]} allowed - The allowable values\n *\n * @throws Error if the value is not allowable\n */\nvar validateEnum = module.exports.validateEnum = function (val, allowed) {\n  if (!_.isUndefined(allowed) && !_.isUndefined(val) && allowed.indexOf(val) === -1) {\n    throwErrorWithCode('ENUM_MISMATCH', 'Not an allowable value (' + allowed.join(', ') + '): ' + val);\n  }\n};\n\n/**\n * Validates the value is less than the maximum (when necessary).\n *\n * @param {*} val - The parameter value\n * @param {string} maximum - The maximum value\n * @param {boolean} [exclusive=false] - Whether or not the value includes the maximum in its comparison\n *\n * @throws Error if the value is greater than the maximum\n */\nvar validateMaximum = module.exports.validateMaximum = function (val, maximum, type, exclusive) {\n  var code = exclusive === true ? 'MAXIMUM_EXCLUSIVE' : 'MAXIMUM';\n  var testMax;\n  var testVal;\n\n  if (_.isUndefined(exclusive)) {\n    exclusive = false;\n  }\n\n  if (type === 'integer') {\n    testVal = parseInt(val, 10);\n  } else if (type === 'number') {\n    testVal = parseFloat(val);\n  }\n\n  if (!_.isUndefined(maximum)) {\n    testMax = parseFloat(maximum);\n\n    if (exclusive && testVal >= testMax) {\n      throwErrorWithCode(code, 'Greater than or equal to the configured maximum (' + maximum + '): ' + val);\n    } else if (testVal > testMax) {\n      throwErrorWithCode(code, 'Greater than the configured maximum (' + maximum + '): ' + val);\n    }\n  }\n};\n\n/**\n * Validates the array count is less than the maximum (when necessary).\n *\n * @param {*[]} val - The parameter value\n * @param {number} maxItems - The maximum number of items\n *\n * @throws Error if the value contains more items than allowable\n */\nvar validateMaxItems = module.exports.validateMaxItems = function (val, maxItems) {\n  if (!_.isUndefined(maxItems) && val.length > maxItems) {\n    throwErrorWithCode('ARRAY_LENGTH_LONG', 'Array is too long (' + val.length + '), maximum ' + maxItems);\n  }\n};\n\n/**\n * Validates the value length is less than the maximum (when necessary).\n *\n * @param {*[]} val - The parameter value\n * @param {number} maxLength - The maximum length\n *\n * @throws Error if the value's length is greater than the maximum\n */\nvar validateMaxLength = module.exports.validateMaxLength = function (val, maxLength) {\n  if (!_.isUndefined(maxLength) && val.length > maxLength) {\n    throwErrorWithCode('MAX_LENGTH', 'String is too long (' + val.length + ' chars), maximum ' + maxLength);\n  }\n};\n\n/**\n * Validates the value's property count is greater than the maximum (when necessary).\n *\n * @param {*[]} val - The parameter value\n * @param {number} minProperties - The maximum number of properties\n *\n * @throws Error if the value's property count is less than the maximum\n */\nvar validateMaxProperties = module.exports.validateMaxProperties = function (val, maxProperties) {\n  var propCount = _.isPlainObject(val) ? Object.keys(val).length : 0;\n\n  if (!_.isUndefined(maxProperties) && propCount > maxProperties) {\n    throwErrorWithCode('MAX_PROPERTIES',\n                       'Number of properties is too many (' + propCount + ' properties), maximum ' + maxProperties);\n  }\n};\n\n/**\n * Validates the value array count is greater than the minimum (when necessary).\n *\n * @param {*} val - The parameter value\n * @param {string} minimum - The minimum value\n * @param {boolean} [exclusive=false] - Whether or not the value includes the minimum in its comparison\n *\n * @throws Error if the value is less than the minimum\n */\nvar validateMinimum = module.exports.validateMinimum = function (val, minimum, type, exclusive) {\n  var code = exclusive === true ? 'MINIMUM_EXCLUSIVE' : 'MINIMUM';\n  var testMin;\n  var testVal;\n\n  if (_.isUndefined(exclusive)) {\n    exclusive = false;\n  }\n\n  if (type === 'integer') {\n    testVal = parseInt(val, 10);\n  } else if (type === 'number') {\n    testVal = parseFloat(val);\n  }\n\n  if (!_.isUndefined(minimum)) {\n    testMin = parseFloat(minimum);\n\n    if (exclusive && testVal <= testMin) {\n      throwErrorWithCode(code, 'Less than or equal to the configured minimum (' + minimum + '): ' + val);\n    } else if (testVal < testMin) {\n      throwErrorWithCode(code, 'Less than the configured minimum (' + minimum + '): ' + val);\n    }\n  }\n};\n\n/**\n * Validates the value value contains fewer items than allowed (when necessary).\n *\n * @param {*[]} val - The parameter value\n * @param {number} minItems - The minimum number of items\n *\n * @throws Error if the value contains fewer items than allowable\n */\nvar validateMinItems = module.exports.validateMinItems = function (val, minItems) {\n  if (!_.isUndefined(minItems) && val.length < minItems) {\n    throwErrorWithCode('ARRAY_LENGTH_SHORT', 'Array is too short (' + val.length + '), minimum ' + minItems);\n  }\n};\n\n/**\n * Validates the value length is less than the minimum (when necessary).\n *\n * @param {*[]} val - The parameter value\n * @param {number} minLength - The minimum length\n *\n * @throws Error if the value's length is less than the minimum\n */\nvar validateMinLength = module.exports.validateMinLength = function (val, minLength) {\n  if (!_.isUndefined(minLength) && val.length < minLength) {\n    throwErrorWithCode('MIN_LENGTH', 'String is too short (' + val.length + ' chars), minimum ' + minLength);\n  }\n};\n\n/**\n * Validates the value's property count is less than or equal to the minimum (when necessary).\n *\n * @param {*[]} val - The parameter value\n * @param {number} minProperties - The minimum number of properties\n *\n * @throws Error if the value's property count is less than the minimum\n */\nvar validateMinProperties = module.exports.validateMinProperties = function (val, minProperties) {\n  var propCount = _.isPlainObject(val) ? Object.keys(val).length : 0;\n\n  if (!_.isUndefined(minProperties) && propCount < minProperties) {\n    throwErrorWithCode('MIN_PROPERTIES',\n                       'Number of properties is too few (' + propCount + ' properties), minimum ' + minProperties);\n  }\n};\n\n/**\n * Validates the value is a multiple of the provided number (when necessary).\n *\n * @param {*[]} val - The parameter value\n * @param {number} multipleOf - The number that should divide evenly into the value\n *\n * @throws Error if the value contains fewer items than allowable\n */\nvar validateMultipleOf = module.exports.validateMultipleOf = function (val, multipleOf) {\n  if (!_.isUndefined(multipleOf) && val % multipleOf !== 0) {\n    throwErrorWithCode('MULTIPLE_OF', 'Not a multiple of ' + multipleOf);\n  }\n};\n\n/**\n * Validates the value matches a pattern (when necessary).\n *\n * @param {string} name - The parameter name\n * @param {*} val - The parameter value\n * @param {string} pattern - The pattern\n *\n * @throws Error if the value does not match the pattern\n */\nvar validatePattern = module.exports.validatePattern = function (val, pattern) {\n  if (!_.isUndefined(pattern) && _.isNull(val.match(new RegExp(pattern)))) {\n    throwErrorWithCode('PATTERN', 'Does not match required pattern: ' + pattern);\n  }\n};\n\n/**\n * Validates the value requiredness (when necessary).\n *\n * @param {*} val - The parameter value\n * @param {boolean} required - Whether or not the parameter is required\n *\n * @throws Error if the value is required but is not present\n */\nmodule.exports.validateRequiredness = function (val, required) {\n  if (!_.isUndefined(required) && required === true && _.isUndefined(val)) {\n    throwErrorWithCode('REQUIRED', 'Is required');\n  }\n};\n\n/**\n * Validates the value type and format (when necessary).\n *\n * @param {string} version - The Swagger version\n * @param {*} val - The parameter value\n * @param {string} type - The parameter type\n * @param {string} format - The parameter format\n * @param {boolean} [skipError=false] - Whether or not to skip throwing an error (Useful for validating arrays)\n *\n * @throws Error if the value is not the proper type or format\n */\nvar validateTypeAndFormat = module.exports.validateTypeAndFormat =\n  function validateTypeAndFormat (version, val, type, format, allowEmptyValue, skipError) {\n    var result = true;\n    var oVal = val;\n\n    // If there is an empty value and we allow empty values, the value is always valid\n    if (allowEmptyValue === true && val === '') {\n      return;\n    }\n\n    if (_.isArray(val)) {\n      _.each(val, function (aVal, index) {\n        if (!validateTypeAndFormat(version, aVal, type, format, allowEmptyValue, true)) {\n          throwErrorWithCode('INVALID_TYPE', 'Value at index ' + index + ' is not a valid ' + type + ': ' + aVal);\n        }\n      });\n    } else {\n      switch (type) {\n      case 'boolean':\n        // Coerce the value only for Swagger 1.2\n        if (version === '1.2' && _.isString(val)) {\n          if (val === 'false') {\n            val = false;\n          } else if (val === 'true') {\n            val = true;\n          }\n        }\n\n        result = _.isBoolean(val);\n        break;\n      case 'integer':\n        // Coerce the value only for Swagger 1.2\n        if (version === '1.2' && _.isString(val)) {\n          val = Number(val);\n        }\n\n        result = _.isFinite(val) && (Math.round(val) === val);\n        break;\n      case 'number':\n        // Coerce the value only for Swagger 1.2\n        if (version === '1.2' && _.isString(val)) {\n          val = Number(val);\n        }\n\n        result = _.isFinite(val);\n        break;\n      case 'string':\n        if (!_.isUndefined(format)) {\n          switch (format) {\n          case 'date':\n            result = isValidDate(val);\n            break;\n          case 'date-time':\n            result = isValidDateTime(val);\n            break;\n          }\n        }\n        break;\n      case 'void':\n        result = _.isUndefined(val);\n        break;\n      }\n    }\n\n    if (skipError) {\n      return result;\n    } else if (!result) {\n      throwErrorWithCode('INVALID_TYPE',\n                         type !== 'void' ?\n                           'Not a valid ' + (_.isUndefined(format) ? '' : format + ' ') + type + ': ' + oVal :\n                           'Void does not allow a value');\n    }\n  };\n\n/**\n * Validates the value values are unique (when necessary).\n *\n * @param {string[]} val - The parameter value\n * @param {boolean} isUnique - Whether or not the parameter values are unique\n *\n * @throws Error if the value has duplicates\n */\nvar validateUniqueItems = module.exports.validateUniqueItems = function (val, isUnique) {\n  if (!_.isUndefined(isUnique) && _.uniq(val).length !== val.length) {\n    throwErrorWithCode('ARRAY_UNIQUE', 'Does not allow duplicate values: ' + val.join(', '));\n  }\n};\n\n/**\n * Validates the value against the schema.\n *\n * @param {string} version - The Swagger version\n * @param {object} schema - The schema to use to validate things\n * @param {string[]} path - The path to the schema\n * @param {*} [val] - The value to validate or undefined to use the default value provided by the schema\n *\n * @throws Error if any validation failes\n */\nvar validateSchemaConstraints = module.exports.validateSchemaConstraints = function (version, schema, path, val) {\n  var resolveSchema = function (schema) {\n    var resolved = schema;\n\n    if (resolved.schema) {\n      path = path.concat(['schema']);\n\n      resolved = resolveSchema(resolved.schema);\n    }\n\n    return resolved;\n  };\n\n  var type = schema.type;\n  var allowEmptyValue;\n\n  if (!type) {\n    if (!schema.schema) {\n      if (path[path.length - 2] === 'responses') {\n        type = 'void';\n      } else {\n        type = 'object';\n      }\n    } else {\n      schema = resolveSchema(schema);\n      type = schema.type || 'object';\n    }\n  }\n\n  allowEmptyValue = schema ? schema.allowEmptyValue === true : false;\n\n  try {\n    // Always perform this check even if there is no value\n    if (type === 'array') {\n      validateArrayType(schema);\n    }\n\n    // Default to default value if necessary\n    if (_.isUndefined(val)) {\n      val = version === '1.2' ? schema.defaultValue : schema.default;\n\n      path = path.concat([version === '1.2' ? 'defaultValue' : 'default']);\n    }\n\n    // If there is no explicit default value, return as all validations will fail\n    if (_.isUndefined(val)) {\n      return;\n    }\n\n    if (type === 'array') {\n      _.each(val, function (val, index) {\n        try {\n          validateSchemaConstraints(version, schema.items || {}, path.concat(index.toString()), val);\n        } catch (err) {\n          err.message = 'Value at index ' + index + ' ' + (err.code === 'INVALID_TYPE' ? 'is ' : '') +\n            err.message.charAt(0).toLowerCase() + err.message.substring(1);\n\n          throw err;\n        }\n      });\n    } else {\n      validateTypeAndFormat(version, val, type, schema.format, allowEmptyValue);\n    }\n\n    // Validate enum\n    validateEnum(val, schema.enum);\n\n    // Validate maximum\n    validateMaximum(val, schema.maximum, type, schema.exclusiveMaximum);\n\n\n    // Validate maxItems (Swagger 2.0+)\n    validateMaxItems(val, schema.maxItems);\n\n    // Validate maxLength (Swagger 2.0+)\n    validateMaxLength(val, schema.maxLength);\n\n    // Validate maxProperties (Swagger 2.0+)\n    validateMaxProperties(val, schema.maxProperties);\n\n    // Validate minimum\n    validateMinimum(val, schema.minimum, type, schema.exclusiveMinimum);\n\n    // Validate minItems\n    validateMinItems(val, schema.minItems);\n\n    // Validate minLength (Swagger 2.0+)\n    validateMinLength(val, schema.minLength);\n\n    // Validate minProperties (Swagger 2.0+)\n    validateMinProperties(val, schema.minProperties);\n\n    // Validate multipleOf (Swagger 2.0+)\n    validateMultipleOf(val, schema.multipleOf);\n\n    // Validate pattern (Swagger 2.0+)\n    validatePattern(val, schema.pattern);\n\n    // Validate uniqueItems\n    validateUniqueItems(val, schema.uniqueItems);\n  } catch (err) {\n    err.path = path;\n\n    throw err;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-swagger/node_modules/swagger/lib/util/cli.js":"/****************************************************************************\n Copyright 2015 Apigee Corporation\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n ****************************************************************************/\n'use strict';\n\nvar _ = require('lodash');\nvar inquirer = require('inquirer');\nvar feedback = require('./feedback');\nvar config = require('../../config');\nvar yaml = require('js-yaml');\nvar util = require('util');\n\nmodule.exports = {\n  requireAnswers: requireAnswers,\n  updateAnswers: updateAnswers,\n  printAndExit: printAndExit,\n  chooseOne: chooseOne,\n  validate: validate,\n  execute: execute,\n  confirm: confirm,\n  prompt: prompt,\n  version: version\n};\n\nfunction version() {\n  return require('../../package.json').version;\n}\n\n// questions are array of objects like these:\n// { name: 'key', message: 'Your prompt?' }\n// { name: 'key', message: 'Your prompt?', type: 'password' }\n// { name: 'key', message: 'Your prompt?', type: 'list', choices: ['1', '2'] }\n// results is an (optional) object containing existing results like this: { key: value }\nfunction requireAnswers(questions, results, cb) {\n  if (!cb) { cb = results; results = {}; }\n  var unanswered = getUnanswered(questions, results);\n  if (unanswered.length === 0) {\n    return cb(results);\n  }\n  inquirer.prompt(unanswered, function(answers) {\n    _.extend(results, answers);\n    requireAnswers(questions, results, cb);\n  });\n}\n\nfunction updateAnswers(questions, results, cb) {\n  if (!cb) { cb = results; results = {}; }\n  for (var i = 0; i < questions.length; i++) {\n    var question = questions[i];\n    if (question.type !== 'password') {\n      question.default = results[question.name];\n    }\n  }\n  inquirer.prompt(questions, function(answers) {\n    _.extend(results, answers);\n    requireAnswers(questions, results, cb);\n  });\n}\n\nfunction getUnanswered(questions, results) {\n  var unanswered = [];\n  for (var i = 0; i < questions.length; i++) {\n    var question = questions[i];\n    if (!results[question.name]) {\n      unanswered.push(question);\n    }\n  }\n  return unanswered;\n}\n\nfunction printAndExit(err, output, code) {\n  if (err) {\n    print(err);\n    code = code || 1;\n  } else if (output !== null && output !== undefined) {\n    print(output);\n  }\n  process.exit(code || 0);\n}\n\nfunction print(object) {\n  if (util.isError(object)) {\n    console.log(config.debug ? object.stack : object);\n  } else if (_.isObject(object)) {\n    if (object.password) {\n      object.password = '******';\n    }\n    console.log(yaml.safeDump(object, { indent: 2 }));\n  } else if (object !== null && object !== undefined) {\n    console.log(object);\n  } else {\n    console.log();\n  }\n}\n\n// prompt: 'Your prompt?', choices: ['1', '2'] }\n// result passed to cb() is the choice selected\nfunction chooseOne(prompt, choices, cb) {\n  var questions = { name: 'x', message: prompt, type: 'list', choices: choices };\n  inquirer.prompt(questions, function(answers) {\n    cb(answers.x);\n  });\n}\n\n// defaultBool is optional (default == true)\n// result passed to cb() is the choice selected\nfunction confirm(prompt, defaultBool, cb) {\n  if (!cb) { cb = defaultBool; defaultBool = true; }\n  var question = { name: 'x', message: prompt, type: 'confirm', default: defaultBool};\n  inquirer.prompt(question, function(answers) {\n    cb(answers.x);\n  });\n}\n\n// defaultValue is optional\n// result passed to cb() is the response\nfunction prompt(prompt, defaultValue, cb) {\n  if (!cb) { cb = defaultValue; defaultValue = undefined; }\n  var question = { name: 'x', message: prompt, default: defaultValue};\n  inquirer.prompt(question, function(answers) {\n    cb(answers.x);\n  });\n}\n\nfunction validate(app) {\n  var commands = app.commands.map(function(command) { return command._name; });\n  if (!_.contains(commands, app.rawArgs[2])) {\n    if (app.rawArgs[2]) {\n      console.log();\n      console.log('error: invalid command: ' + app.rawArgs[2]);\n    }\n    app.help();\n  }\n}\n\nfunction execute(command, header) {\n  var cb = function(err, reply) {\n    if (header && !err) {\n      print(header);\n      print(Array(header.length + 1).join('='));\n    }\n    if (!reply && !err) { reply = 'done'; }\n    printAndExit(err, reply);\n  };\n  return function() {\n    try {\n      var args = Array.prototype.slice.call(arguments);\n      args.push(cb);\n      if (!command) {\n        return cb(new Error('missing command method'));\n      }\n      if (args.length !== command.length) {\n        return cb(new Error('incorrect arguments'));\n      }\n      var reply = command.apply(this, args);\n      if (reply) {\n        cb(null, reply);\n      }\n    } catch (err) {\n      cb(err);\n    }\n  }\n}\n\nif (typeof String.prototype.endsWith !== 'function') {\n  String.prototype.endsWith = function(suffix) {\n    return this.indexOf(suffix, this.length - suffix.length) !== -1;\n  };\n}\n\nfeedback.on(function(feedback) {\n  if (_.isString(feedback) && feedback.endsWith('\\\\')) {\n    process.stdout.write(feedback.substr(0, feedback.length - 1));\n  } else {\n    print(feedback);\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-swagger/node_modules/swagger/bin/swagger-project.js":"#!/usr/bin/env node\n/****************************************************************************\n Copyright 2015 Apigee Corporation\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n ****************************************************************************/\n'use strict';\n\nvar app = require('commander');\nvar project = require('../lib/commands/project/project');\nvar cli = require('../lib/util/cli');\nvar execute = cli.execute;\nvar frameworks = Object.keys(project.frameworks).join('|');\nvar assertiontypes = project.assertiontypes.join('|');\nvar testmodules = project.testmodules.join('|');\n\napp\n  .command('create [name]')\n  .description('Create a folder containing a Swagger project')\n  .option('-f, --framework <framework>', 'one of: ' + frameworks)\n  .action(execute(project.create));\n\napp\n  .command('start [directory]')\n  .description('Start the project in this or the specified directory')\n  .option('-d, --debug [port]', 'start in remote debug mode')\n  .option('-b, --debug-brk [port]', 'start in remote debug mode, wait for debugger connect')\n  .option('-m, --mock', 'start in mock mode')\n  .option('-o, --open', 'open browser as client to the project')\n  .option('-n, --node-args <args>', 'run node with extra arguments (like --node-args \\\"--harmony\\\")')\n  .action(execute(project.start));\n\napp\n  .command('verify [directory]')\n  .description('Verify that the project is correct (swagger, config, etc)')\n  .option('-j, --json', 'output as JSON')\n  .action(execute(project.verify));\n\napp\n  .command('edit [directory]')\n  .description('open Swagger editor for this project or the specified project directory')\n  .option('-s, --silent', 'do not open the browser')\n  .option('--host <host>', 'the hostname the editor is served from')\n  .option('-p, --port <port>', 'the port the editor is served from')\n  .action(execute(project.edit));\n\napp\n  .command('open [directory]')\n  .description('open browser as client to the project')\n  .action(execute(project.open));\n\napp\n  .command('test [directory_or_file]')\n  .description('Run project tests')\n  .option('-d, --debug [port]', 'start in remote debug mode')\n  .option('-b, --debug-brk [port]', 'start in remote debug mode, wait for debugger connect')\n  .option('-m, --mock', 'run in mock mode')\n  .action(execute(project.test));\n\napp\n  .command('generate-test [directory]')\n  .description('Generate the test template')\n  .option('-p, --path-name [path]', 'a specific path of the api, also supports regular expression')\n  .option('-f, --test-module <module>', 'one of: ' + testmodules)\n  .option('-t, --assertion-format <type>', 'one of: ' + assertiontypes)\n  .option('-o, --force', 'allow overwriting of all existing test files matching those generated')\n  .option('-l, --load-test [path]', 'generate load-tests for specified operations')\n  .action(execute(project.generateTest));\n\napp.parse(process.argv);\ncli.validate(app);\n","/home/travis/build/npmtest/node-npmtest-swagger/node_modules/swagger/lib/commands/project/project.js":"/****************************************************************************\n Copyright 2015 Apigee Corporation\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n ****************************************************************************/\n'use strict';\n\nvar config = require('../../../config');\nvar _ = require('lodash');\nvar path = require('path');\nvar fs = require('fs-extra');\nvar emit = require('../../util/feedback').emit;\nvar netutil = require('../../util/net');\nvar debug = require('debug')('swagger');\nvar util = require('util');\nvar cli = require('../../util/cli');\nvar template = require('swagger-test-templates');\nvar async = require('async');\nvar swaggerSpec = require('../../util/spec');\nvar spec = require('swagger-tools').specs.v2;\nvar inquirer = require('inquirer');\n\nvar FRAMEWORKS = {\n  connect: { source: 'connect' },\n  express: { source: 'connect', overlay: 'express' },\n  hapi:    { source: 'connect', overlay: 'hapi' },\n  restify: { source: 'connect', overlay: 'restify' },\n  sails:   { source: 'sails' }\n};\n\nvar TEST_ASSERTION_TYPES = ['expect', 'should', 'assert'];\nvar TEST_MODULES = ['supertest', 'request'];\nvar TEST_DEPENDENCIES = {\n  'z-schema': '^3.12.0',\n  request: '^2.58.0',\n  chai: '^3.0.0',\n  mocha: '^2.2.5',\n  dotenv: '^1.2.0'\n};\n\nmodule.exports = {\n  create: create,\n  start: start,\n  verify: verify,\n  edit: edit,\n  open: open,\n  test: test,\n\n  // for internal use\n  frameworks: FRAMEWORKS,\n  read: readProject,\n  assertiontypes: TEST_ASSERTION_TYPES,\n  testmodules: TEST_MODULES,\n\n  // for testing stub generating\n  generateTest: testGenerate\n};\n\n//.option('-f, --framework <framework>', 'one of: connect | express')\nfunction create(name, options, cb) {\n  function validateName(name) {\n    var targetDir = path.resolve(process.cwd(), name);\n    if (fs.existsSync(targetDir)) {\n      return 'Directory ' + targetDir + ' already exists.';\n    }\n    return true;\n  }\n\n  if (name) {\n    var valid = validateName(name);\n    if (typeof valid === 'string') { return cb(new Error(valid)); }\n  }\n\n  if (options.framework && !FRAMEWORKS[options.framework]) {\n    return cb(new Error(util.format('Unknown framework: %j. Valid frameworks: %s', options.framework, Object.keys(FRAMEWORKS).join(', '))));\n  }\n\n  var questions = [\n    { name: 'name', message: 'Project name?', validate: validateName },\n    { name: 'framework', message: 'Framework?', type: 'list', choices: Object.keys(FRAMEWORKS) }\n  ];\n\n  var results = {\n    name: name,\n    framework: options.framework\n  };\n\n  cli.requireAnswers(questions, results, function(results) {\n\n    var name = results.name;\n    var framework = results.framework;\n    var targetDir = path.resolve(process.cwd(), name);\n\n    cloneSkeleton(name, framework, targetDir, function(err) {\n      if (err) { return cb(err); }\n      emit('Project %s created in %s', name, targetDir);\n\n      var message = util.format('Success! You may start your new app by running: \"swagger project start %s\"', name);\n\n      installDependencies(targetDir, message, cb);\n    });\n  });\n}\n\n//.option('-d, --debug [port]', 'start in remote debug mode')\n//.option('-b, --debug-brk [port]', 'start in remote debug mode, wait for debugger connect')\n//.option('-m, --mock', 'start in mock mode')\n//.option('-o, --open', 'open in browser')\nfunction start(directory, options, cb) {\n\n  readProject(directory, options, function(err, project) {\n    if (err) { throw err; }\n\n    var fullPath = path.join(project.dirname, project.api.main);\n    emit('Starting: %s...', fullPath);\n    var nodemonOpts = {\n      script: project.api.main,\n      ext: 'js,json,yaml,coffee',\n      nodeArgs: []\n    };\n    if (project.dirname) { nodemonOpts.cwd = project.dirname; }\n    if (options.debugBrk) {\n      var debugBrkArg = '--debug-brk';\n      if (typeof options.debugBrk === 'string') {\n        debugBrkArg += '=' + options.debugBrk;\n      }\n      nodemonOpts.nodeArgs.push(debugBrkArg);\n    }\n    if (options.debug) {\n      var debugArg = '--debug';\n      if (typeof options.debug === 'string') {\n        debugArg += '=' + options.debug;\n      }\n      nodemonOpts.nodeArgs.push(debugArg);\n    }\n    if (options.nodeArgs) {\n      nodemonOpts.nodeArgs = nodemonOpts.nodeArgs.concat(options.nodeArgs.split(' '));\n    }\n    // https://www.npmjs.com/package/cors\n    nodemonOpts.env = {\n      swagger_corsOptions: '{}' // enable CORS so editor \"try it\" function can work\n    };\n    if (options.mock) {\n      nodemonOpts.env.swagger_mockMode = true\n    }\n    var nodemon = require('nodemon');\n    // hack to enable proxyquire stub for testing...\n    if (_.isFunction(nodemon)) {\n      nodemon(nodemonOpts);\n    } else {\n      nodemon._init(nodemonOpts, cb);\n    }\n    nodemon.on('start', function () {\n      emit('  project started here: ' + project.api.localUrl);\n      emit('  project will restart on changes.');\n      emit('  to restart at any time, enter `rs`');\n\n      if (options.open) {\n        setTimeout(function() {\n          open(directory, options, cb);\n        }, 500);\n      }\n    }).on('restart', function (files) {\n      emit('Project restarted. Files changed: ', files);\n    }).on('quit', function () {\n      process.exit(0);\n    });\n  });\n}\n\n//.option('-d, --debug [port]', 'start in remote debug mode')\n//.option('-b, --debug-brk [port]', 'start in remote debug mode, wait for debugger connect')\n//.option('-m, --mock', 'start in mock mode')\n//.option('-o, --open', 'open in browser')\nfunction test(directory, options, cb) {\n\n  var Mocha = require('mocha');\n  var MochaUtils = require('mocha/lib/utils');\n\n  readProject(directory, options, function(err, project) {\n\n    if (err) { return cb(err); }\n\n    var mocha = new Mocha();\n    var testPath = project.dirname;\n    if (directory) {\n      try {\n        testPath = fs.realpathSync(directory);\n      } catch (err) {\n        return cb(new Error(util.format('no such file or directory %s', directory)));\n      }\n    }\n    testPath = path.resolve(testPath, 'test');\n    debug('testPath: %s', testPath);\n\n    if (fs.statSync(testPath).isFile()) {\n      if (testPath.substr(-3) !== '.js') { return cb(new Error('file is not a javascript file')); }\n      mocha.addFile(testPath);\n      debug('mocha addFile: %s', testPath);\n    } else {\n      MochaUtils.lookupFiles(testPath, ['js'], true)\n        .forEach(function(file) {\n          mocha.addFile(file);\n          debug('mocha addFile: %s', file);\n        });\n    }\n\n    emit('Running tests in: %s...', testPath);\n\n    if (options.mock) {\n      process.env.swagger_mockMode = true;\n    }\n    mocha.run(function(failures) {\n      cb(null, failures);\n    });\n  });\n}\n\nfunction verify(directory, options, cb) {\n\n  readProject(directory, options, function(err, project) {\n    if (err) { return cb(err); }\n\n    swaggerSpec.validateSwagger(project.api.swagger, options, cb);\n  });\n}\n\nfunction edit(directory, options, cb) {\n\n  readProject(directory, options, function(err, project) {\n    if (err) { return cb(err); }\n    var editor = require('./swagger_editor');\n    editor.edit(project, options, cb);\n  });\n}\n\nfunction open(directory, options, cb) {\n\n  readProject(directory, options, function(err, project) {\n    if (err) { return cb(err); }\n\n    netutil.isPortOpen(project.api.port, function(err, isOpen) {\n      if (err) { return cb(err); }\n      if (isOpen) {\n        var browser = require('../../util/browser');\n        browser.open(project.api.localUrl, cb);\n      } else {\n        emit('Project does not appear to be listening on port %d.', project.api.port);\n      }\n    });\n  });\n}\n\n// Utility\n\nfunction readProject(directory, options, cb) {\n\n  findProjectFile(directory, options, function(err, fileName) {\n    if (err) { return cb(err); }\n\n    var yaml = require('js-yaml');\n    var Url = require('url');\n\n    var string = fs.readFileSync(fileName, { encoding: 'utf8' });\n    var project = JSON.parse(string);\n\n    project.filename = fileName;\n    project.dirname = path.dirname(fileName);\n\n    if (!project.api) { project.api = {}; }\n\n    project.api.swaggerFile = path.resolve(project.dirname, config.swagger.fileName);\n    project.api.swagger = yaml.safeLoad(fs.readFileSync(project.api.swaggerFile, 'utf8'));\n\n    project.api.name = project.name;\n    project.api.main = project.main;\n    project.api.host = project.api.swagger.host;\n    project.api.basePath = project.api.swagger.basePath;\n\n    project.api.localUrl = 'http://' + project.api.host + project.api.swagger.basePath;\n    project.api.port = Url.parse(project.api.localUrl).port || 80;\n\n    debug('project.api: %j', _.omit(project.api, 'swagger'));\n    cb(null, project);\n  });\n}\n\n// .option('-p, --project', 'use specified project file')\nfunction findProjectFile(startDir, options, cb) {\n\n  var parent = startDir = startDir || process.cwd();\n  var maxDepth = 50;\n  var current = null;\n  while (current !== parent && maxDepth-- > 0) {\n    current = parent;\n    var projectFile = path.resolve(current, 'package.json');\n    if (fs.existsSync(projectFile)) {\n      return cb(null, projectFile);\n    }\n    parent = path.join(current, '..');\n  }\n  cb(new Error('Project root not found in or above: ' + startDir));\n}\n\nfunction cloneSkeleton(name, framework, destDir, cb) {\n\n  var skeletonsDir = config.project.skeletonsDir;\n\n  framework = FRAMEWORKS[framework];\n  var sourceDir = path.resolve(skeletonsDir, framework.source);\n  var overlayDir = (framework.overlay) ? path.resolve(skeletonsDir, framework.overlay) : null;\n\n  var done = function(err) {\n    if (err) { return cb(err); }\n    customizeClonedFiles(name, framework, destDir, cb);\n  };\n\n  debug('copying source files from %s', sourceDir);\n  fs.copy(sourceDir, destDir, true, function(err) {\n    if (err) { return cb(err); }\n    if (overlayDir) {\n      debug('copying overlay files from %s', overlayDir);\n      fs.copy(overlayDir, destDir, false, done);\n    } else {\n      done();\n    }\n  });\n}\n\nfunction customizeClonedFiles(name, framework, destDir, cb) {\n\n  // npm renames .gitignore to .npmignore, change it back\n  var npmignore = path.resolve(destDir, '.npmignore');\n  var gitignore = path.resolve(destDir, '.gitignore');\n  fs.rename(npmignore, gitignore, function(err) {\n    if (err && !fs.existsSync(gitignore)) { return cb(err); }\n\n    // rewrite package.json\n    var fileName = path.resolve(destDir, 'package.json');\n    fs.readFile(fileName, { encoding: 'utf8' }, function(err, string) {\n      if (err) { return cb(err); }\n\n      var project = JSON.parse(string);\n      project.name = name;\n\n      debug('writing project: %j', project);\n      fs.writeFile(fileName, JSON.stringify(project, null, '  '), cb);\n    });\n  });\n}\n\nfunction spawn(command, options, cwd, cb) {\n\n  var cp = require('child_process');\n  var os = require('os');\n\n  var isWin = /^win/.test(os.platform());\n\n  emit('Running \"%s %s\"...', command, options.join(' '));\n\n  var npm = cp.spawn(isWin ?\n                       process.env.comspec :\n                       command,\n                     isWin ?\n                       ['/c'].concat(command, options) :\n                       options,\n                     { cwd: cwd });\n  npm.stdout.on('data', function (data) {\n    emit(data);\n  });\n  npm.stderr.on('data', function(data) {\n    emit('%s', data);\n  });\n  npm.on('close', function(exitCode) {\n    if (exitCode !== 0) { var err = new Error('exit code: ' + exitCode); }\n    cb(err);\n  });\n  npm.on('error', function(err) {\n    cb(err);\n  });\n}\n\n\n//.option('-p, --path-name [path]', 'a sepecific path of the api')\n//.option('-f, --test-module <module>', 'one of: ' + testmodules)\n//.option('-t, --assertion-format <type>', 'one of: ' + assertiontypes)\n//.option('-o, --force', 'allow overwriting of all existing test files matching those generated')\nfunction testGenerate(directory, options, cb) {\n  var pathList = [];\n  var desiredPaths = [];\n  var testModule = options.testModule || TEST_MODULES[0];\n  var assertionFormat = options.assertionFormat || TEST_ASSERTION_TYPES[0];\n  var overwriteAll = options.force || false;\n  var loadTesting = options.loadTest || false;\n  directory = directory || process.cwd();\n\n  findProjectFile(directory, null, function(err, projPath) {\n    var projectFile;\n    var projectJson = require(projPath);\n    var jsonCopy = _.cloneDeep(projectJson);\n    var runInstall = false;\n\n    if (err) { return cb(err); }\n\n    if (!_.isEqual(jsonCopy.devDependencies, _.defaultsDeep(projectJson.devDependencies, TEST_DEPENDENCIES))) {\n      runInstall = true;\n    }\n\n    _.defaultsDeep(projectJson, {scripts: {test: 'swagger project test'}});\n\n    projectFile = JSON.stringify(projectJson, null, 2);\n\n    fs.writeFileSync(projPath, projectFile);\n\n    if (!fs.existsSync(path.join(directory, 'test/api/client'))) {\n      fs.mkdirSync(path.join(directory, 'test/api/client'));\n    }\n\n    //read the yaml file and validate it\n    readProject(directory, options, function(err, project) {\n      if (err) { return cb(err); }\n      swaggerSpec.validateSwagger(project.api.swagger, options, function(err) {\n        spec.resolve(project.api.swagger, function(err, result) {\n          // get the array of string paths from json object\n          pathList = Object.keys(result.paths);\n\n          //check if the test frame is one of the two\n          if (options.testModule && !_.includes(TEST_MODULES, options.testModule)) {\n            return cb(new Error(util.format('Unknown type: %j. Valid types: %s', options.testModule, TEST_MODULES.join(', '))));\n          }\n\n          // check if the assertion-format is one of the three\n          if (options.assertionFormat && !_.includes(TEST_ASSERTION_TYPES, options.assertionFormat)) {\n            return cb(new Error(util.format('Unknown type: %j. Valid types: %s', options.assertionFormat, TEST_ASSERTION_TYPES.join(', '))));\n          }\n\n          // process the paths option\n          if (options.pathName){\n            var reg = new RegExp(options.pathName);\n            desiredPaths = pathList.filter(function(val) {\n              return val.match(reg);\n            });\n          }\n\n          // pass the config to the module and get the result string array\n          var config = {\n            pathName: desiredPaths,\n            testModule: testModule,\n            assertionFormat: assertionFormat\n          };\n\n          // pass list of paths targeted for load testing\n          if (loadTesting) {\n            if ((typeof loadTesting) !== 'boolean' && fs.existsSync(path.join(directory, loadTesting))) {\n              config.loadTest = parseJsonFile(directory, loadTesting).loadTargets;\n            } else if (fs.existsSync(path.join(directory, 'load-config.json'))){\n              config.loadTest = parseJsonFile(directory, 'load-config.json').loadTargets;\n            } else {\n              return cb(new Error('Config file not found. Please specify a load test config or add load-config.json file to your project directory.'));\n            }\n          }\n\n          var finalResult = template.testGen(result, config);\n          var existingFiles = fs.readdirSync(path.join(directory, 'test/api/client'));\n          var skipAll = false;\n\n          async.filterSeries(finalResult, function(file, cb) {\n            if (overwriteAll) {\n              cb(true);\n            } else if(skipAll){\n              cb(false);\n            } else {\n              if (_.includes(existingFiles, file.name)) {\n                var prompt = util.format('Conflict on %s. Overwrite? (answer \\'h\\' for help):', file.name);\n                var question = {type: 'expand', message: prompt, name: 'overwrite', choices: [\n                  {\n                    key: \"y\",\n                    name: \"Overwrite this one and show the next\",\n                    value: \"overwrite\"\n                  },\n                  {\n                    key: \"a\",\n                    name: \"Overwrite this one and all of the next\",\n                    value: \"overwrite_all\"\n                  },\n                  {\n                    key: 'n',\n                    name: 'Skip this one and show the next',\n                    value: 'overwrite_skip'\n                  },\n                  {\n                    key: 'x',\n                    name: 'Skip this one and all of the next',\n                    value: 'overwrite_skip_all'\n                  }\n                ]};\n\n                inquirer.prompt(question, function(answers) {\n                  if (answers.overwrite === 'overwrite') {\n                    cb(true);\n                  } else if (answers.overwrite === 'overwrite_all') {\n                    overwriteAll = true;\n                    cb(true);\n                  } else if (answers.overwrite === 'overwrite_skip') {\n                    cb(false);\n                  } else {\n                    skipAll = true;\n                    cb(false);\n                  }\n                });\n              } else {\n                cb(true);\n              }\n            }\n          }, function(filteredResult) {\n\n            async.each(filteredResult, function(file, cb) {\n              if (file.name === '.env') {\n                fs.outputFile(path.join(directory, file.name), file.test, cb);\n              } else {\n                fs.outputFile(path.join(directory, '/test/api/client', file.name), file.test, cb);\n              }\n            }, function(err) {\n              if (runInstall) {\n                installDependencies(directory, 'Success! You may now run your tests.', cb);\n              }\n            });\n          });\n        });\n      });\n    });\n  });\n}\n\nfunction parseJsonFile(directory, filePath) {\n  return JSON.parse(fs.readFileSync(path.join(directory, filePath)));\n}\n\nfunction installDependencies(directory, message, cb) {\n  spawn('npm', ['install'], directory, function(err) {\n    if (err) {\n      emit('\"npm install\" failed. Please run \"npm install\" in %s.', directory);\n      return cb(err);\n    }\n    cb(null, message);\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-swagger/node_modules/swagger/lib/util/net.js":"/****************************************************************************\n Copyright 2015 Apigee Corporation\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n ****************************************************************************/\n'use strict';\n\nvar net = require('net');\nvar debug = require('debug')('swagger');\nvar http = require('http');\nvar https = require('https');\nvar fs = require('fs');\nvar _ = require('lodash');\n\nvar DEFAULT_TIMEOUT = 100;\n\nmodule.exports = {\n  isPortOpen: isPortOpen\n};\n\nfunction isPortOpen(port, timeout, cb) {\n  if (!cb) { cb = timeout; timeout = DEFAULT_TIMEOUT; }\n  cb = _.once(cb);\n\n  var s = new net.Socket();\n\n  s.setTimeout(timeout, function() {\n    s.destroy();\n    cb(null, false);\n  });\n  s.connect(port, function() {\n    cb(null, true);\n  });\n\n  s.on('error', function(err) {\n    s.destroy();\n    if (err.code === 'ECONNREFUSED') { err = null; }\n    cb(err, false);\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-swagger/node_modules/swagger-test-templates/index.js":"/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2015 Apigee Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n'use strict';\n\nvar TYPE_JSON = 'application/json';\nvar handlebars = require('handlebars');\nvar sanitize = require('sanitize-filename');\nvar fs = require('fs');\nvar _ = require('lodash');\nvar url = require('url');\nvar path = require('path');\nvar deref = require('json-schema-deref-sync');\nvar helpers = require('./lib/helpers.js');\n\n/**\n * To check if it is an empty array or undefined\n * @private\n * @param  {array/object} val an array to be checked\n * @returns {boolean} return true is the array is not empty nor undefined\n */\nfunction isEmpty(val) {\n  return val == null || val.length <= 0;\n}\n\n/**\n * Populate property of the swagger project\n * @private\n * @param  {json} swagger swagger file containing API\n * @param  {string} apiPath API path to generate tests for\n * @param  {string} operation operation of the path to generate tests for\n * @param  {string} response response type of operation of current path\n * @param  {json} config configuration for testGen\n * @param  {info} info for cascading properties\n * @returns {json} return all the properties information\n */\nfunction getData(swagger, apiPath, operation, response, config, info) {\n  var childProperty = swagger.paths[apiPath];\n  var grandProperty = swagger.paths[apiPath][operation];\n  var securityType;\n\n  var responseDescription = (swagger.paths[apiPath][operation].responses[response]) ?\n    swagger.paths[apiPath][operation].responses[response].description : '';\n  var data = { // request payload\n    responseCode: response,\n    default: response === 'default' ? 'default' : null,\n    description: (response + ' ' + responseDescription),\n    assertion: config.assertionFormat,\n    noSchema: true,\n    bodyParameters: [],\n    queryParameters: [],\n    headerParameters: [],\n    pathParameters: [],\n    formParameters: [],\n    queryApiKey: null,\n    headerApiKey: null,\n    headerSecurity: null,\n    path: '',\n    isLoadTest: false,\n    loadName: '',\n    requests: 0,\n    concurrent: 0,\n    pathParams: {}\n  };\n\n  // get pathParams from config\n  if (config.pathParams) {\n    data.pathParams = config.pathParams;\n  }\n\n  // used for checking requestData table\n  var requestPath = (swagger.basePath) ? path.join(swagger.basePath, apiPath) : apiPath;\n\n\n  // cope with loadTest info\n  if (info.loadTest != null) {\n    _.forEach(info.loadTest, function(loadTestParam) {\n      if (loadTestParam.pathName === apiPath && loadTestParam.operation === operation) {\n        data.loadName = apiPath.replace(/\\//g, '_') + '_' + operation + '_load_test';\n        info.importArete = true;\n        data.isLoadTest = true;\n        data.requests = loadTestParam.load.requests !== undefined ? loadTestParam.load.requests : 1000;\n        data.concurrent = loadTestParam.load.concurrent !== undefined ? loadTestParam.load.concurrent : 100;\n      }\n    });\n  }\n\n  // deal with the security properties\n  if (info.security && info.security.length !== 0) {\n    Object.keys(info.security[0]).forEach(function(element) {\n      securityType = swagger.securityDefinitions[element];\n      element = _.snakeCase(element).toUpperCase();\n      switch (securityType.type) {\n        case 'basic':\n          data.headerSecurity = {name: element, type: 'Basic'};\n          break;\n        case 'apiKey':\n          if (securityType.in === 'query') {\n            data.queryApiKey =\n            {name: element, type: securityType.name};\n          } else if (securityType.in === 'header') {\n            data.headerApiKey =\n            {name: element, type: securityType.name};\n          }\n          break;\n        case 'oauth2':\n          data.headerSecurity = {name: element, type: 'Bearer'};\n          break;\n        default:\n          throw new Error('The type is undefined.');\n      }\n    });\n  }\n\n  // deal with parameters in path level\n  if (childProperty.hasOwnProperty('parameters')) {\n    // process different parameters\n    _.forEach(childProperty.parameters, function(parameter) {\n      switch (parameter.in) {\n        case 'query':\n          data.queryParameters.push(parameter);\n          break;\n        case 'path':\n          data.pathParameters.push(parameter);\n          break;\n        case 'header':\n          data.headerParameters.push(parameter);\n          break;\n        case 'formData':\n          data.formParameters.push(parameter);\n          break;\n        default:\n          throw new Error('The type is undefined.');\n      }\n    });\n  }\n\n  // deal with parameters in operation level\n  if (grandProperty.hasOwnProperty('parameters')) {\n    // only adds body parameters to request, ignores query params\n    _.forEach(grandProperty.parameters, function(parameter) {\n      switch (parameter.in) {\n        case 'query':\n          data.queryParameters.push(parameter);\n          break;\n        case 'header':\n          data.headerParameters.push(parameter);\n          break;\n        case 'path':\n          data.pathParameters.push(parameter);\n          break;\n        case 'formData':\n          data.formParameters.push(parameter);\n          break;\n        case 'body':\n          data.bodyParameters.push(parameter);\n          break;\n        default:\n          throw new Error('The type is undefined.');\n      }\n    });\n  }\n\n  if (grandProperty.responses[response].hasOwnProperty('schema')) {\n    data.noSchema = false;\n    data.schema = grandProperty.responses[response].schema;\n    data.schema = JSON.stringify(data.schema, null, 2);\n  }\n\n  // request url case\n  if (config.testModule === 'request') {\n    data.path = url.format({\n      protocol: swagger.schemes !== undefined ? swagger.schemes[0] : 'http',\n      host: swagger.host !== undefined ? swagger.host : 'localhost:10010',\n      pathname: requestPath\n    });\n  } else {\n    data.path = requestPath;\n  }\n\n  // get requestData from config if defined for this path:operation:response\n  if (config.requestData &&\n    config.requestData[requestPath] &&\n    config.requestData[requestPath][operation] &&\n    config.requestData[requestPath][operation][response]) {\n    data.requestData = config.requestData[requestPath][operation][response];\n    // if we have a GET request AND requestData, fill the path params accordingly\n    if (operation === 'get') {\n      var mockParameters = {};\n\n      data.pathParameters.forEach(function(parameter) {\n        // find the mock data for this parameter name\n        mockParameters[parameter.name] = data.requestData.filter(function(mock) {\n          return mock.hasOwnProperty(parameter.name);\n        })[0][parameter.name];\n      });\n      // only write parameters if they are not already defined in config\n      // @todo we should rework this with code above to be more readable\n      if (!config.pathParams) {\n        data.pathParams = mockParameters;\n      }\n    }\n  }\n  return data;\n}\n\n/**\n * Builds a unit test stubs for the response code of a apiPath's operation\n * @private\n * @param  {json} swagger swagger file containing API\n * @param  {string} apiPath API apiPath to generate tests for\n * @param  {string} operation operation of the apiPath to generate tests for\n * @param  {string} response response type of operation of current apiPath\n * @param  {json} config configuration for testGen\n * @param  {string} consume content-type consumed by request\n * @param {string} produce content-type produced by the response\n * @param  {info} info for cascading properties\n * @returns {string} generated test for response type\n */\nfunction testGenResponse(swagger, apiPath, operation, response, config, consume, produce, info) {\n  var result;\n  var templateFn;\n  var source;\n  var data;\n\n  // get the data\n  data = getData(swagger, apiPath, operation, response, config, info);\n  if (produce === TYPE_JSON && !data.noSchema) {\n    info.importValidator = true;\n  }\n\n  if (info.security && info.security.length !== 0) {\n    info.importEnv = true;\n  }\n\n  data.contentType = consume;\n  data.returnType = produce;\n\n  // compile template source and return test string\n  var templatePath = path.join(config.templatesPath, config.testModule, operation, operation + '.handlebars');\n\n  source = fs.readFileSync(templatePath, 'utf8');\n  templateFn = handlebars.compile(source, {noEscape: true});\n\n  if (data.requestData && data.requestData.length > 0) {\n    result = '';\n    for (var i = 0; i < data.requestData.length; i++) {\n      data.request = JSON.stringify(data.requestData[i].body);\n      data.requestMessage = data.requestData[i].description.replace(/'/g, \"\\\\'\");  // eslint-disable-line quotes\n      result += templateFn(data);\n    }\n  } else {\n    result = templateFn(data);\n  }\n\n  return result;\n}\n\nfunction testGenContentTypes(swagger, apiPath, operation, res, config, info) {\n  var result = [];\n  var ndxC;\n  var ndxP;\n\n  if (!isEmpty(info.consumes)) { // consumes is defined\n    for (ndxC in info.consumes) {\n      if (!isEmpty(info.produces)) { // produces is defined\n        for (ndxP in info.produces) {\n          if (info.produces[ndxP] !== undefined) {\n            result.push(testGenResponse(swagger, apiPath, operation, res, config, info.consumes[ndxC], info.produces[ndxP], info));\n          }\n        }\n      } else { // produces is not defined\n        result.push(testGenResponse(swagger, apiPath, operation, res, config, info.consumes[ndxC], TYPE_JSON, info));\n      }\n    }\n  } else if (!isEmpty(info.produces)) {\n    // consumes is undefined but produces is defined\n    for (ndxP in info.produces) {\n      if (info.produces[ndxP] !== undefined) {\n        result.push(testGenResponse(swagger, apiPath, operation, res, config, TYPE_JSON, info.produces[ndxP], info));\n      }\n    }\n  } else { // neither produces nor consumes are defined\n    result.push(testGenResponse(swagger, apiPath, operation, res, config, TYPE_JSON, TYPE_JSON, info));\n  }\n\n  return result;\n}\n\n/**\n * Builds a set of unit test stubs for all response codes of a\n *  apiPath's operation\n * @private\n * @param  {json} swagger swagger file containing API\n * @param  {string} apiPath API apiPath to generate tests for\n * @param  {string} operation operation of the apiPath to generate tests for\n * @param  {json} config configuration for testGen\n * @param  {info} info for cascading properties\n * @returns {string|Array} set of all tests for a apiPath's operation\n */\nfunction testGenOperation(swagger, apiPath, operation, config, info) {\n\n  var responses = swagger.paths[apiPath][operation].responses;\n\n  // filter out the wanted codes\n  if (config.statusCodes) {\n    responses = {};\n    config.statusCodes.forEach(function(code) {\n      responses[code] = swagger.paths[apiPath][operation].responses[code];\n    });\n  }\n\n  var result = [];\n  var source;\n  var innerDescribeFn;\n\n  source = fs.readFileSync(path.join(config.templatesPath, '/innerDescribe.handlebars'), 'utf8');\n  innerDescribeFn = handlebars.compile(source, {noEscape: true});\n\n  // determines which produce types to use\n  if (!isEmpty(swagger.paths[apiPath][operation].produces)) {\n    info.produces = swagger.paths[apiPath][operation].produces;\n  } else if (!isEmpty(swagger.produces)) {\n    info.produces = swagger.produces;\n  } else {\n    info.produces = [];\n  }\n\n  // determines which consumes types to use\n  if (!isEmpty(swagger.paths[apiPath][operation].consumes)) {\n    info.consumes = swagger.paths[apiPath][operation].consumes;\n  } else if (!isEmpty(swagger.consumes)) {\n    info.consumes = swagger.consumes;\n  } else {\n    info.consumes = [];\n  }\n\n  // determines which security to use\n  if (!isEmpty(swagger.paths[apiPath][operation].security)) {\n    info.security = swagger.paths[apiPath][operation].security;\n  } else if (!isEmpty(swagger.security)) {\n    info.security = swagger.security;\n  } else {\n    info.security = [];\n  }\n\n  _.forEach(responses, function(response, responseCode) {\n    result = result.concat(testGenContentTypes(swagger, apiPath, operation, responseCode, config, info));\n  });\n\n  var output;\n  var data = {\n    description: operation,\n    tests: result\n  };\n\n\n  output = innerDescribeFn(data);\n\n  return output;\n}\n\n/**\n * Builds a set of unit test stubs for all of a apiPath's operations\n * @private\n * @param  {json} swagger swagger file containing API\n * @param  {string} apiPath API apiPath to generate tests for\n * @param  {json} config configuration for testGen\n * @returns {string|Array} set of all tests for a apiPath\n */\nfunction testGenPath(swagger, apiPath, config) {\n  var childProperty = swagger.paths[apiPath];\n  var result = [];\n  var validOps = ['get', 'put', 'post', 'delete', 'options', 'head', 'patch'];\n  var allDeprecated = true;\n  var outerDescribeFn;\n  var source;\n  var info = {\n    importValidator: false,\n    importEnv: false,\n    importArete: false,\n    consumes: [],\n    produces: [],\n    security: [],\n    loadTest: null\n  };\n\n  if (config.loadTest) {\n    info.loadTest = config.loadTest;\n  }\n\n  source = fs.readFileSync(path.join(config.templatesPath, '/outerDescribe.handlebars'), 'utf8');\n  outerDescribeFn = handlebars.compile(source, {noEscape: true});\n\n  _.forEach(childProperty, function(property, propertyName) {\n    if (_.includes(validOps, propertyName) && !property.deprecated) {\n      allDeprecated = false;\n      result.push(testGenOperation(swagger, apiPath, propertyName, config, info));\n    }\n  });\n\n  var output = '';\n  var customFormats = fs.readFileSync(require.resolve('./custom-formats'), 'utf-8');\n\n  var data = {\n    description: apiPath,\n    assertion: config.assertionFormat,\n    testmodule: config.testModule,\n    customFormats: customFormats,\n    scheme: (swagger.schemes !== undefined ? swagger.schemes[0] : 'http'),\n    host: (swagger.host !== undefined ? swagger.host : 'localhost:10010'),\n    tests: result,\n    importValidator: info.importValidator,\n    importEnv: info.importEnv,\n    importArete: info.importArete\n  };\n\n  if (!allDeprecated) {\n    output = outerDescribeFn(data);\n    info.importValidator = false;\n  }\n  return output;\n}\n\n/**\n * Builds unit test stubs for all paths specified by the configuration\n * @public\n * @param  {json} swagger swagger file containing API\n * @param  {json} config configuration for testGen\n * @returns {string|Array} set of all tests for a swagger API\n */\nfunction testGen(swagger, config) {\n  var paths = swagger.paths;\n  var targets = config.pathName;\n  var result = [];\n  var output = [];\n  var i = 0;\n  var source;\n  var filename;\n  var schemaTemp;\n  var environment;\n  var ndx = 0;\n\n  config.templatesPath = (config.templatesPath) ? config.templatesPath : path.join(__dirname, 'templates');\n\n  swagger = deref(swagger);\n  source = fs.readFileSync(path.join(config.templatesPath, '/schema.handlebars'), 'utf8');\n  schemaTemp = handlebars.compile(source, {noEscape: true});\n  handlebars.registerPartial('schema-partial', schemaTemp);\n  source = fs.readFileSync(path.join(config.templatesPath, '/environment.handlebars'), 'utf8');\n  environment = handlebars.compile(source, {noEscape: true});\n  helpers.setLen(80);\n\n  if (config.maxLen && !isNaN(config.maxLen)) {\n    helpers.setLen(config.maxLen);\n  }\n\n  if (!targets || targets.length === 0) {\n    // builds tests for all paths in API\n    _.forEach(paths, function(apipath, pathName) {\n      result.push(testGenPath(swagger, pathName, config));\n    });\n  } else {\n    // loops over specified paths from config\n    _.forEach(targets, function(target) {\n      result.push(testGenPath(swagger, target, config));\n    });\n  }\n\n  // no specified paths to build, so build all of them\n  if (!targets || targets.length === 0) {\n    _.forEach(result, function(results) {\n      output.push({\n        name: '-test.js',\n        test: results\n      });\n    });\n\n    // build file names with paths\n    _.forEach(paths, function(apipath, pathName) {\n      // for output file name, replace / with -, and truncate the first /\n      // eg: /hello/world -> hello-world\n      filename = sanitize((pathName.replace(/\\//g, '-').substring(1))\n        + output[i].name);\n      // for base path file name, change it to base-path\n      if (pathName === '/') {\n        filename = 'base-path' + output[i].name;\n      }\n      output[i++].name = filename;\n    });\n  } else {\n    // loops over specified paths\n    _.forEach(targets, function(target) {\n      // for output file name, replace / with -, and truncate the first /\n      // eg: /hello/world -> hello-world\n      filename = sanitize((target.replace(/\\//g, '-').substring(1))\n        + '-test.js');\n      // for base path file name, change it to base-path\n      if (target === '/') {\n        filename = 'base-path' + '-test.js';\n      }\n      output.push({\n        name: filename,\n        test: result[ndx++]\n      });\n    });\n  }\n\n  if (swagger.securityDefinitions) {\n    var keys = Object.keys(swagger.securityDefinitions);\n\n    keys.forEach(function(element, index, array) {\n      array[index] = _.snakeCase(element).toUpperCase();\n    });\n    var data = {envVars: keys};\n    var envText = environment(data);\n\n    output.push({\n      name: '.env',\n      test: envText\n    });\n  }\n  return output;\n}\n\nhandlebars.registerHelper('is', helpers.is);\nhandlebars.registerHelper('ifCond', helpers.ifCond);\nhandlebars.registerHelper('validateResponse', helpers.validateResponse);\nhandlebars.registerHelper('length', helpers.length);\nhandlebars.registerHelper('pathify', helpers.pathify);\nhandlebars.registerHelper('printJSON', helpers.printJSON);\n\n\nmodule.exports = {\n  testGen: testGen\n};\n","/home/travis/build/npmtest/node-npmtest-swagger/node_modules/swagger-test-templates/lib/helpers.js":"'use strict';\n\nvar _ = require('lodash');\nvar strObj = require('string');\nvar url = require('url');\nvar TYPE_JSON = 'application/json';\nvar len;\n\nmodule.exports = {\n  is: is,\n  ifCond: ifCond,\n  validateResponse: validateResponse,\n  length: length,\n  pathify: pathify,\n  printJSON: printJSON,\n  len: len,\n  setLen: setLen\n};\n\nfunction setLen(descriptionLength) {\n  len = descriptionLength\n}\n\n// http://goo.gl/LFoiYG\nfunction is(lvalue, rvalue, options) {\n  if (arguments.length < 3) {\n    throw new Error('Handlebars Helper \\'is\\' needs 2 parameters');\n  }\n\n  if (lvalue !== rvalue) {\n    return options.inverse(this);\n  } else {\n    return options.fn(this);\n  }\n}\n\n// http://goo.gl/LFoiYG\nfunction ifCond(v1, v2, options) {\n  if (arguments.length < 3) {\n    throw new Error('Handlebars Helper \\'ifCond\\' needs 2 parameters');\n  }\n  if (v1.length > 0 || v2) {\n    return options.fn(this);\n  }\n  return options.inverse(this);\n}\n\n/**\n * determines if content types are able to be validated\n * @param  {string} type     content type to be evaluated\n * @param  {boolean} noSchema whether or not there is a defined schema\n * @param  {Object} options  handlebars built-in options\n * @returns {boolean}          whether or not the content can be validated\n */\nfunction validateResponse(type, noSchema,\n  options) {\n  if (arguments.length < 3) {\n    throw new Error('Handlebars Helper \\'validateResponse\\'' +\n      'needs 2 parameters');\n  }\n\n  if (!noSchema && type === TYPE_JSON) {\n    return options.fn(this);\n  } else {\n    return options.inverse(this);\n  }\n}\n\n/**\n * replaces path params with obvious indicator for filling values\n * (i.e. if any part of the path is surrounded in curly braces {})\n * @param  {string} path  request path to be pathified\n * @param  {object} pathParams contains path parameters to replace with\n * @returns {string}          pathified string\n */\nfunction pathify(path, pathParams) {\n  var r;\n\n  if (arguments.length < 3) {\n    throw new Error('Handlebars Helper \\'pathify\\'' +\n      ' needs 2 parameters');\n  }\n\n  if ((typeof path) !== 'string') {\n    throw new TypeError('Handlebars Helper \\'pathify\\'' +\n      'requires path to be a string');\n  }\n\n  if ((typeof pathParams) !== 'object') {\n    throw new TypeError('Handlebars Helper \\'pathify\\'' +\n      'requires pathParams to be an object');\n  }\n\n  if (Object.keys(pathParams).length > 0) {\n    var re = new RegExp(/(?:\\{+)(.*?(?=\\}))(?:\\}+)/g);\n    var re2;\n    var matches = [];\n    var m = re.exec(path);\n    var i;\n\n    while (m) {\n      matches.push(m[1]);\n      m = re.exec(path);\n    }\n\n    for (i = 0; i < matches.length; i++) {\n      var match = matches[i];\n\n      re2 = new RegExp('(\\\\{+)' + match + '(?=\\\\})(\\\\}+)');\n\n      if (typeof (pathParams[match]) !== 'undefined' && pathParams[match] !== null) {\n        path = path.replace(re2, pathParams[match]);\n      } else {\n        path = path.replace(re2, '{' + match + ' PARAM GOES HERE}');\n      }\n    }\n    return path;\n  }\n\n  r = new RegExp(/(?:\\{+)(.*?(?=\\}))(?:\\}+)/g);\n  return path.replace(r, '{$1 PARAM GOES HERE}');\n}\n\n/**\n * split the long description into multiple lines\n * @param  {string} description  request description to be splitted\n * @returns {string}        multiple lines\n */\nfunction length(description) {\n  if (arguments.length < 2) {\n    throw new Error('Handlebar Helper \\'length\\'' +\n    ' needs 1 parameter');\n  }\n\n  if ((typeof description) !== 'string') {\n    throw new TypeError('Handlebars Helper \\'length\\'' +\n      'requires path to be a string');\n  }\n\n  if (len === -1) { // toggle off truncation, this is a noop\n    return description;\n  }\n\n  return strObj(description).truncate(len - 50).s;\n}\n\nfunction printJSON(data) {\n  if (arguments.length < 2) {\n    throw new Error('Handlebar Helper \\'printJSON\\'' +\n    ' needs at least 1 parameter');\n  }\n\n  if (data !== null) {\n    if ((typeof data) === 'string') {\n      return '\\'' + data + '\\'';\n    } else if ((typeof data) === 'object') {\n      return '{\\n'+prettyPrintJson(data, '        ')+'\\n      }';\n    } else {\n      return data;\n    }\n  } else {\n    return null;\n  }\n}\n\n// http://goo.gl/7DbFS\nfunction prettyPrintJson(obj, indent) {\n  var result = '';\n\n  if (indent == null) indent = '';\n\n  for (var property in obj) {\n    if (property.charAt(0) !== '_') {\n      var value = obj[property];\n\n      if (typeof value === 'string') {\n        value = '\\'' + value + '\\'';\n      } else if (typeof value === 'object') {\n        if (value instanceof Array) {\n          value = '[ ' + value + ' ]';\n        } else {\n          // Recursive dump\n          var od = prettyPrintJson(value, indent + '  ');\n\n          value = '{\\n' + od + '\\n' + indent + '}';\n        }\n      }\n      result += indent + property + ': ' + value + ',\\n';\n    }\n  }\n  return result.replace(/,\\n$/, '');\n}\n","/home/travis/build/npmtest/node-npmtest-swagger/node_modules/swagger/project-skeletons/connect/app.js":"'use strict';\n\nvar SwaggerConnect = require('swagger-connect');\nvar app = require('connect')();\nmodule.exports = app; // for testing\n\nvar config = {\n  appRoot: __dirname // required config\n};\n\nSwaggerConnect.create(config, function(err, swaggerConnect) {\n  if (err) { throw err; }\n\n  // install middleware\n  swaggerConnect.register(app);\n\n  var port = process.env.PORT || 10010;\n  app.listen(port);\n\n  if (swaggerConnect.runner.swagger.paths['/hello']) {\n    console.log('try this:\\ncurl http://127.0.0.1:' + port + '/hello?name=Scott');\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-swagger/node_modules/swagger/project-skeletons/sails/Gruntfile.js":"/**\n * Gruntfile\n *\n * This Node script is executed when you run `grunt` or `sails lift`.\n * It's purpose is to load the Grunt tasks in your project's `tasks`\n * folder, and allow you to add and remove tasks as you see fit.\n * For more information on how this works, check out the `README.md`\n * file that was generated in your `tasks` folder.\n *\n * WARNING:\n * Unless you know what you're doing, you shouldn't change this file.\n * Check out the `tasks` directory instead.\n */\n\nmodule.exports = function(grunt) {\n\n\n\t// Load the include-all library in order to require all of our grunt\n\t// configurations and task registrations dynamically.\n\tvar includeAll;\n\ttry {\n\t\tincludeAll = require('include-all');\n\t} catch (e0) {\n\t\ttry {\n\t\t\tincludeAll = require('sails/node_modules/include-all');\n\t\t}\n\t\tcatch(e1) {\n\t\t\tconsole.error('Could not find `include-all` module.');\n\t\t\tconsole.error('Skipping grunt tasks...');\n\t\t\tconsole.error('To fix this, please run:');\n\t\t\tconsole.error('npm install include-all --save`');\n\t\t\tconsole.error();\n\n\t\t\tgrunt.registerTask('default', []);\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\t/**\n\t * Loads Grunt configuration modules from the specified\n\t * relative path. These modules should export a function\n\t * that, when run, should either load/configure or register\n\t * a Grunt task.\n\t */\n\tfunction loadTasks(relPath) {\n\t\treturn includeAll({\n\t\t\tdirname: require('path').resolve(__dirname, relPath),\n\t\t\tfilter: /(.+)\\.js$/\n\t\t}) || {};\n\t}\n\n\t/**\n\t * Invokes the function from a Grunt configuration module with\n\t * a single argument - the `grunt` object.\n\t */\n\tfunction invokeConfigFn(tasks) {\n\t\tfor (var taskName in tasks) {\n\t\t\tif (tasks.hasOwnProperty(taskName)) {\n\t\t\t\ttasks[taskName](grunt);\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\n\t// Load task functions\n\tvar taskConfigurations = loadTasks('./tasks/config'),\n\t\tregisterDefinitions = loadTasks('./tasks/register');\n\n\t// (ensure that a default task exists)\n\tif (!registerDefinitions.default) {\n\t\tregisterDefinitions.default = function (grunt) { grunt.registerTask('default', []); };\n\t}\n\n\t// Run task functions to configure Grunt.\n\tinvokeConfigFn(taskConfigurations);\n\tinvokeConfigFn(registerDefinitions);\n\n};\n"}